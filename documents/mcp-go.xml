This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter), security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
    release.yml
client/
  client.go
  sse_test.go
  sse.go
  stdio_test.go
  stdio.go
  types.go
examples/
  custom_context/
    main.go
  everything/
    main.go
  filesystem_stdio_client/
    main.go
mcp/
  prompts.go
  resources.go
  tools_test.go
  tools.go
  types.go
  utils.go
server/
  internal/
    gen/
      data.go
      hooks.go.tmpl
      main.go
      README.md
      request_handler.go.tmpl
  hooks.go
  request_handler.go
  server_test.go
  server.go
  sse_test.go
  sse.go
  stdio_test.go
  stdio.go
testdata/
  mockstdio_server.go
.gitignore
go.mod
LICENSE
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
name: go
on:
  push:
    branches:
      - main
  pull_request:
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-go@v5
      with:
        go-version-file: 'go.mod'
    - run: go test ./... -race
</file>

<file path=".github/workflows/release.yml">
name: "Create Release on Tag Push"
on:
  push:
    tags:
      - '*'  
jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false
</file>

<file path="client/client.go">
// Package client provides MCP (Model Control Protocol) client implementations.
package client
⋮----
import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/mark3labs/mcp-go/mcp"
)
⋮----
"context"
"encoding/json"
"fmt"
⋮----
"github.com/mark3labs/mcp-go/mcp"
⋮----
// MCPClient represents an MCP client interface
type MCPClient interface {
	// Initialize sends the initial connection request to the server
	Initialize(
		ctx context.Context,
		request mcp.InitializeRequest,
	) (*mcp.InitializeResult, error)

	// Ping checks if the server is alive
	Ping(ctx context.Context) error

	// ListResourcesByPage manually list resources by page.
	ListResourcesByPage(
		ctx context.Context,
		request mcp.ListResourcesRequest,
	) (*mcp.ListResourcesResult, error)

	// ListResources requests a list of available resources from the server
	ListResources(
		ctx context.Context,
		request mcp.ListResourcesRequest,
	) (*mcp.ListResourcesResult, error)

	// ListResourceTemplatesByPage manually list resource templates by page.
	ListResourceTemplatesByPage(
		ctx context.Context,
		request mcp.ListResourceTemplatesRequest,
	) (*mcp.ListResourceTemplatesResult,
		error)

	// ListResourceTemplates requests a list of available resource templates from the server
	ListResourceTemplates(
		ctx context.Context,
		request mcp.ListResourceTemplatesRequest,
	) (*mcp.ListResourceTemplatesResult,
		error)

	// ReadResource reads a specific resource from the server
	ReadResource(
		ctx context.Context,
		request mcp.ReadResourceRequest,
	) (*mcp.ReadResourceResult, error)

	// Subscribe requests notifications for changes to a specific resource
	Subscribe(ctx context.Context, request mcp.SubscribeRequest) error

	// Unsubscribe cancels notifications for a specific resource
	Unsubscribe(ctx context.Context, request mcp.UnsubscribeRequest) error

	// ListPromptsByPage manually list prompts by page.
	ListPromptsByPage(
		ctx context.Context,
		request mcp.ListPromptsRequest,
	) (*mcp.ListPromptsResult, error)

	// ListPrompts requests a list of available prompts from the server
	ListPrompts(
		ctx context.Context,
		request mcp.ListPromptsRequest,
	) (*mcp.ListPromptsResult, error)

	// GetPrompt retrieves a specific prompt from the server
	GetPrompt(
		ctx context.Context,
		request mcp.GetPromptRequest,
	) (*mcp.GetPromptResult, error)

	// ListToolsByPage manually list tools by page.
	ListToolsByPage(
		ctx context.Context,
		request mcp.ListToolsRequest,
	) (*mcp.ListToolsResult, error)

	// ListTools requests a list of available tools from the server
	ListTools(
		ctx context.Context,
		request mcp.ListToolsRequest,
	) (*mcp.ListToolsResult, error)

	// CallTool invokes a specific tool on the server
	CallTool(
		ctx context.Context,
		request mcp.CallToolRequest,
	) (*mcp.CallToolResult, error)

	// SetLevel sets the logging level for the server
	SetLevel(ctx context.Context, request mcp.SetLevelRequest) error

	// Complete requests completion options for a given argument
	Complete(
		ctx context.Context,
		request mcp.CompleteRequest,
	) (*mcp.CompleteResult, error)

	// Close client connection and cleanup resources
	Close() error

	// OnNotification registers a handler for notifications
	OnNotification(handler func(notification mcp.JSONRPCNotification))
}
⋮----
// Initialize sends the initial connection request to the server
⋮----
// Ping checks if the server is alive
⋮----
// ListResourcesByPage manually list resources by page.
⋮----
// ListResources requests a list of available resources from the server
⋮----
// ListResourceTemplatesByPage manually list resource templates by page.
⋮----
// ListResourceTemplates requests a list of available resource templates from the server
⋮----
// ReadResource reads a specific resource from the server
⋮----
// Subscribe requests notifications for changes to a specific resource
⋮----
// Unsubscribe cancels notifications for a specific resource
⋮----
// ListPromptsByPage manually list prompts by page.
⋮----
// ListPrompts requests a list of available prompts from the server
⋮----
// GetPrompt retrieves a specific prompt from the server
⋮----
// ListToolsByPage manually list tools by page.
⋮----
// ListTools requests a list of available tools from the server
⋮----
// CallTool invokes a specific tool on the server
⋮----
// SetLevel sets the logging level for the server
⋮----
// Complete requests completion options for a given argument
⋮----
// Close client connection and cleanup resources
⋮----
// OnNotification registers a handler for notifications
⋮----
type mcpClient interface {
	MCPClient

	sendRequest(ctx context.Context, method string, params interface{}) (*json.RawMessage, error)
⋮----
func listByPage[T any](
	ctx context.Context,
	client mcpClient,
	request mcp.PaginatedRequest,
	method string,
) (*T, error)
⋮----
var result T
</file>

<file path="client/sse_test.go">
package client
⋮----
import (
	"context"
	"testing"
	"time"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
)
⋮----
"context"
"testing"
"time"
⋮----
"github.com/mark3labs/mcp-go/mcp"
"github.com/mark3labs/mcp-go/server"
⋮----
func TestSSEMCPClient(t *testing.T)
⋮----
// Create MCP server with capabilities
⋮----
// Add a test tool
⋮----
// Initialize
⋮----
// Start the client
⋮----
// Initialize
⋮----
// Test Ping
⋮----
// Test ListTools
⋮----
// t.Run("Can handle notifications", func(t *testing.T) {
// 	client, err := NewSSEMCPClient(testServer.URL + "/sse")
// 	if err != nil {
// 		t.Fatalf("Failed to create client: %v", err)
// 	}
// 	defer client.Close()
⋮----
// 	notificationReceived := make(chan mcp.JSONRPCNotification, 1)
// 	client.OnNotification(func(notification mcp.JSONRPCNotification) {
// 		notificationReceived <- notification
// 	})
⋮----
// 	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
// 	defer cancel()
⋮----
// 	if err := client.Start(ctx); err != nil {
// 		t.Fatalf("Failed to start client: %v", err)
⋮----
// 	// Initialize first
// 	initRequest := mcp.InitializeRequest{}
// 	initRequest.Params.ProtocolVersion = mcp.LATEST_PROTOCOL_VERSION
// 	initRequest.Params.ClientInfo = mcp.Implementation{
// 		Name:    "test-client",
// 		Version: "1.0.0",
⋮----
// 	_, err = client.Initialize(ctx, initRequest)
⋮----
// 		t.Fatalf("Failed to initialize: %v", err)
⋮----
// 	// Subscribe to a resource to test notifications
// 	subRequest := mcp.SubscribeRequest{}
// 	subRequest.Params.URI = "test://resource"
// 	if err := client.Subscribe(ctx, subRequest); err != nil {
// 		t.Fatalf("Failed to subscribe: %v", err)
⋮----
// 	select {
// 	case <-notificationReceived:
// 		// Success
// 	case <-time.After(time.Second):
// 		t.Error("Timeout waiting for notification")
⋮----
// })
⋮----
// Try to make a request without initializing
⋮----
// t.Run("Handles context cancellation", func(t *testing.T) {
⋮----
// 	if err := client.Start(context.Background()); err != nil {
⋮----
// 	ctx, cancel := context.WithCancel(context.Background())
// 	cancel() // Cancel immediately
⋮----
// 	toolsRequest := mcp.ListToolsRequest{}
// 	_, err = client.ListTools(ctx, toolsRequest)
// 	if err == nil {
// 		t.Error("Expected error when context is cancelled")
</file>

<file path="client/sse.go">
package client
⋮----
import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/mark3labs/mcp-go/mcp"
)
⋮----
"bufio"
"bytes"
"context"
"encoding/json"
"errors"
"fmt"
"io"
"net/http"
"net/url"
"strings"
"sync"
"sync/atomic"
"time"
⋮----
"github.com/mark3labs/mcp-go/mcp"
⋮----
// SSEMCPClient implements the MCPClient interface using Server-Sent Events (SSE).
// It maintains a persistent HTTP connection to receive server-pushed events
// while sending requests over regular HTTP POST calls. The client handles
// automatic reconnection and message routing between requests and responses.
type SSEMCPClient struct {
	baseURL       *url.URL
	endpoint      *url.URL
	httpClient    *http.Client
	requestID     atomic.Int64
	responses     map[int64]chan RPCResponse
	mu            sync.RWMutex
	done          chan struct{}
⋮----
type ClientOption func(*SSEMCPClient)
⋮----
func WithHeaders(headers map[string]string) ClientOption
⋮----
// NewSSEMCPClient creates a new SSE-based MCP client with the given base URL.
// Returns an error if the URL is invalid.
func NewSSEMCPClient(baseURL string, options ...ClientOption) (*SSEMCPClient, error)
⋮----
// Start initiates the SSE connection to the server and waits for the endpoint information.
// Returns an error if the connection fails or times out waiting for the endpoint.
func (c *SSEMCPClient) Start(ctx context.Context) error
⋮----
// Wait for the endpoint to be received
⋮----
// Endpoint received, proceed
⋮----
case <-time.After(30 * time.Second): // Add a timeout
⋮----
// readSSE continuously reads the SSE stream and processes events.
// It runs until the connection is closed or an error occurs.
func (c *SSEMCPClient) readSSE(reader io.ReadCloser)
⋮----
var event, data string
⋮----
// Process any pending event before exit
⋮----
// Remove only newline markers
⋮----
// Empty line means end of event
⋮----
// handleSSEEvent processes SSE events based on their type.
// Handles 'endpoint' events for connection setup and 'message' events for JSON-RPC communication.
func (c *SSEMCPClient) handleSSEEvent(event, data string)
⋮----
var baseMessage struct {
			JSONRPC string          `json:"jsonrpc"`
			ID      *int64          `json:"id,omitempty"`
			Method  string          `json:"method,omitempty"`
			Result  json.RawMessage `json:"result,omitempty"`
			Error   *struct {
				Code    int    `json:"code"`
				Message string `json:"message"`
			} `json:"error,omitempty"`
		}
⋮----
// Handle notification
⋮----
var notification mcp.JSONRPCNotification
⋮----
// OnNotification registers a handler function to be called when notifications are received.
// Multiple handlers can be registered and will be called in the order they were added.
func (c *SSEMCPClient) OnNotification(
	handler func(notification mcp.JSONRPCNotification),
)
⋮----
// sendRequest sends a JSON-RPC request to the server and waits for a response.
// Returns the raw JSON response message or an error if the request fails.
func (c *SSEMCPClient) sendRequest(
	ctx context.Context,
	method string,
	params interface
⋮----
// set custom http headers
⋮----
func (c *SSEMCPClient) Initialize(
	ctx context.Context,
	request mcp.InitializeRequest,
) (*mcp.InitializeResult, error)
⋮----
// Ensure we send a params object with all required fields
⋮----
Capabilities:    request.Params.Capabilities, // Will be empty struct if not set
⋮----
var result mcp.InitializeResult
⋮----
// Store capabilities
⋮----
// Send initialized notification
⋮----
func (c *SSEMCPClient) Ping(ctx context.Context) error
⋮----
// ListResourcesByPage manually list resources by page.
func (c *SSEMCPClient) ListResourcesByPage(
	ctx context.Context,
	request mcp.ListResourcesRequest,
) (*mcp.ListResourcesResult, error)
⋮----
func (c *SSEMCPClient) ListResources(
	ctx context.Context,
	request mcp.ListResourcesRequest,
) (*mcp.ListResourcesResult, error)
⋮----
func (c *SSEMCPClient) ListResourceTemplatesByPage(
	ctx context.Context,
	request mcp.ListResourceTemplatesRequest,
) (*mcp.ListResourceTemplatesResult, error)
⋮----
func (c *SSEMCPClient) ListResourceTemplates(
	ctx context.Context,
	request mcp.ListResourceTemplatesRequest,
) (*mcp.ListResourceTemplatesResult, error)
⋮----
func (c *SSEMCPClient) ReadResource(
	ctx context.Context,
	request mcp.ReadResourceRequest,
) (*mcp.ReadResourceResult, error)
⋮----
func (c *SSEMCPClient) Subscribe(
	ctx context.Context,
	request mcp.SubscribeRequest,
) error
⋮----
func (c *SSEMCPClient) Unsubscribe(
	ctx context.Context,
	request mcp.UnsubscribeRequest,
) error
⋮----
func (c *SSEMCPClient) ListPromptsByPage(
	ctx context.Context,
	request mcp.ListPromptsRequest,
) (*mcp.ListPromptsResult, error)
⋮----
func (c *SSEMCPClient) ListPrompts(
	ctx context.Context,
	request mcp.ListPromptsRequest,
) (*mcp.ListPromptsResult, error)
⋮----
func (c *SSEMCPClient) GetPrompt(
	ctx context.Context,
	request mcp.GetPromptRequest,
) (*mcp.GetPromptResult, error)
⋮----
func (c *SSEMCPClient) ListToolsByPage(
	ctx context.Context,
	request mcp.ListToolsRequest,
) (*mcp.ListToolsResult, error)
⋮----
func (c *SSEMCPClient) ListTools(
	ctx context.Context,
	request mcp.ListToolsRequest,
) (*mcp.ListToolsResult, error)
⋮----
func (c *SSEMCPClient) CallTool(
	ctx context.Context,
	request mcp.CallToolRequest,
) (*mcp.CallToolResult, error)
⋮----
func (c *SSEMCPClient) SetLevel(
	ctx context.Context,
	request mcp.SetLevelRequest,
) error
⋮----
func (c *SSEMCPClient) Complete(
	ctx context.Context,
	request mcp.CompleteRequest,
) (*mcp.CompleteResult, error)
⋮----
var result mcp.CompleteResult
⋮----
// Helper methods
⋮----
// GetEndpoint returns the current endpoint URL for the SSE connection.
func (c *SSEMCPClient) GetEndpoint() *url.URL
⋮----
// Close shuts down the SSE client connection and cleans up any pending responses.
// Returns an error if the shutdown process fails.
func (c *SSEMCPClient) Close() error
⋮----
return nil // Already closed
⋮----
// Clean up any pending responses
</file>

<file path="client/stdio_test.go">
package client
⋮----
import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"sync"
	"testing"
	"time"

	"github.com/mark3labs/mcp-go/mcp"
)
⋮----
"context"
"encoding/json"
"fmt"
"log/slog"
"os"
"os/exec"
"path/filepath"
"sync"
"testing"
"time"
⋮----
"github.com/mark3labs/mcp-go/mcp"
⋮----
func compileTestServer(outputPath string) error
⋮----
func TestStdioMCPClient(t *testing.T)
⋮----
// Compile mock server
⋮----
var logRecords []map[string]any
var logRecordsMu sync.RWMutex
var wg sync.WaitGroup
⋮----
var record map[string]any
⋮----
// Test Subscribe
⋮----
// Test Unsubscribe
</file>

<file path="client/stdio.go">
package client
⋮----
import (
	"bufio"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"sync"
	"sync/atomic"

	"github.com/mark3labs/mcp-go/mcp"
)
⋮----
"bufio"
"context"
"encoding/json"
"errors"
"fmt"
"io"
"os"
"os/exec"
"sync"
"sync/atomic"
⋮----
"github.com/mark3labs/mcp-go/mcp"
⋮----
// StdioMCPClient implements the MCPClient interface using stdio communication.
// It launches a subprocess and communicates with it via standard input/output streams
// using JSON-RPC messages. The client handles message routing between requests and
// responses, and supports asynchronous notifications.
type StdioMCPClient struct {
	cmd           *exec.Cmd
	stdin         io.WriteCloser
	stdout        *bufio.Reader
	stderr        io.ReadCloser
	requestID     atomic.Int64
	responses     map[int64]chan RPCResponse
	mu            sync.RWMutex
	done          chan struct{}
⋮----
// NewStdioMCPClient creates a new stdio-based MCP client that communicates with a subprocess.
// It launches the specified command with given arguments and sets up stdin/stdout pipes for communication.
// Returns an error if the subprocess cannot be started or the pipes cannot be created.
func NewStdioMCPClient(
	command string,
	env []string,
	args ...string,
) (*StdioMCPClient, error)
⋮----
// Start reading responses in a goroutine and wait for it to be ready
⋮----
// Close shuts down the stdio client, closing the stdin pipe and waiting for the subprocess to exit.
// Returns an error if there are issues closing stdin or waiting for the subprocess to terminate.
func (c *StdioMCPClient) Close() error
⋮----
// Stderr returns a reader for the stderr output of the subprocess.
// This can be used to capture error messages or logs from the subprocess.
func (c *StdioMCPClient) Stderr() io.Reader
⋮----
// OnNotification registers a handler function to be called when notifications are received.
// Multiple handlers can be registered and will be called in the order they were added.
func (c *StdioMCPClient) OnNotification(
	handler func(notification mcp.JSONRPCNotification),
)
⋮----
// readResponses continuously reads and processes responses from the server's stdout.
// It handles both responses to requests and notifications, routing them appropriately.
// Runs until the done channel is closed or an error occurs reading from stdout.
func (c *StdioMCPClient) readResponses()
⋮----
var baseMessage struct {
				JSONRPC string          `json:"jsonrpc"`
				ID      *int64          `json:"id,omitempty"`
				Method  string          `json:"method,omitempty"`
				Result  json.RawMessage `json:"result,omitempty"`
				Error   *struct {
					Code    int    `json:"code"`
					Message string `json:"message"`
				} `json:"error,omitempty"`
			}
⋮----
// Handle notification
⋮----
var notification mcp.JSONRPCNotification
⋮----
// sendRequest sends a JSON-RPC request to the server and waits for a response.
// It creates a unique request ID, sends the request over stdin, and waits for
// the corresponding response or context cancellation.
// Returns the raw JSON response message or an error if the request fails.
func (c *StdioMCPClient) sendRequest(
	ctx context.Context,
	method string,
	params interface
⋮----
// Create the complete request structure
⋮----
func (c *StdioMCPClient) Ping(ctx context.Context) error
⋮----
func (c *StdioMCPClient) Initialize(
	ctx context.Context,
	request mcp.InitializeRequest,
) (*mcp.InitializeResult, error)
⋮----
// This structure ensures Capabilities is always included in JSON
⋮----
Capabilities:    request.Params.Capabilities, // Will be empty struct if not set
⋮----
var result mcp.InitializeResult
⋮----
// Store capabilities
⋮----
// Send initialized notification
⋮----
// ListResourcesByPage manually list resources by page.
func (c *StdioMCPClient) ListResourcesByPage(
	ctx context.Context,
	request mcp.ListResourcesRequest,
) (*mcp.ListResourcesResult, error)
⋮----
func (c *StdioMCPClient) ListResources(
	ctx context.Context,
	request mcp.ListResourcesRequest,
) (*mcp.ListResourcesResult, error)
⋮----
func (c *StdioMCPClient) ListResourceTemplatesByPage(
	ctx context.Context,
	request mcp.ListResourceTemplatesRequest,
) (*mcp.ListResourceTemplatesResult, error)
⋮----
func (c *StdioMCPClient) ListResourceTemplates(
	ctx context.Context,
	request mcp.ListResourceTemplatesRequest,
) (*mcp.ListResourceTemplatesResult, error)
⋮----
func (c *StdioMCPClient) ReadResource(
	ctx context.Context,
	request mcp.ReadResourceRequest,
) (*mcp.ReadResourceResult,
	error)
⋮----
func (c *StdioMCPClient) Subscribe(
	ctx context.Context,
	request mcp.SubscribeRequest,
) error
⋮----
func (c *StdioMCPClient) Unsubscribe(
	ctx context.Context,
	request mcp.UnsubscribeRequest,
) error
⋮----
func (c *StdioMCPClient) ListPromptsByPage(
	ctx context.Context,
	request mcp.ListPromptsRequest,
) (*mcp.ListPromptsResult, error)
⋮----
func (c *StdioMCPClient) ListPrompts(
	ctx context.Context,
	request mcp.ListPromptsRequest,
) (*mcp.ListPromptsResult, error)
⋮----
func (c *StdioMCPClient) GetPrompt(
	ctx context.Context,
	request mcp.GetPromptRequest,
) (*mcp.GetPromptResult, error)
⋮----
func (c *StdioMCPClient) ListToolsByPage(
	ctx context.Context,
	request mcp.ListToolsRequest,
) (*mcp.ListToolsResult, error)
⋮----
func (c *StdioMCPClient) ListTools(
	ctx context.Context,
	request mcp.ListToolsRequest,
) (*mcp.ListToolsResult, error)
⋮----
func (c *StdioMCPClient) CallTool(
	ctx context.Context,
	request mcp.CallToolRequest,
) (*mcp.CallToolResult, error)
⋮----
func (c *StdioMCPClient) SetLevel(
	ctx context.Context,
	request mcp.SetLevelRequest,
) error
⋮----
func (c *StdioMCPClient) Complete(
	ctx context.Context,
	request mcp.CompleteRequest,
) (*mcp.CompleteResult, error)
⋮----
var result mcp.CompleteResult
</file>

<file path="client/types.go">
package client
⋮----
import "encoding/json"
⋮----
type RPCResponse struct {
	Error    *string
	Response *json.RawMessage
}
</file>

<file path="examples/custom_context/main.go">
package main
⋮----
import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
)
⋮----
"context"
"encoding/json"
"flag"
"fmt"
"io"
"log"
"net/http"
"os"
⋮----
"github.com/mark3labs/mcp-go/mcp"
"github.com/mark3labs/mcp-go/server"
⋮----
// authKey is a custom context key for storing the auth token.
type authKey struct{}
⋮----
// withAuthKey adds an auth key to the context.
func withAuthKey(ctx context.Context, auth string) context.Context
⋮----
// authFromRequest extracts the auth token from the request headers.
func authFromRequest(ctx context.Context, r *http.Request) context.Context
⋮----
// authFromEnv extracts the auth token from the environment
func authFromEnv(ctx context.Context) context.Context
⋮----
// tokenFromContext extracts the auth token from the context.
// This can be used by tools to extract the token regardless of the
// transport being used by the server.
func tokenFromContext(ctx context.Context) (string, error)
⋮----
type response struct {
	Args    map[string]interface{} `json:"args"`
⋮----
// makeRequest makes a request to httpbin.org including the auth token in the request
// headers and the message in the query string.
func makeRequest(ctx context.Context, message, token string) (*response, error)
⋮----
var r *response
⋮----
// handleMakeAuthenticatedRequestTool is a tool that makes an authenticated request
// using the token from the context.
func handleMakeAuthenticatedRequestTool(
	ctx context.Context,
	request mcp.CallToolRequest,
) (*mcp.CallToolResult, error)
⋮----
// Now our tool can make a request with the token, irrespective of where it came from.
⋮----
type MCPServer struct {
	server *server.MCPServer
}
⋮----
func NewMCPServer() *MCPServer
⋮----
func (s *MCPServer) ServeSSE(addr string) *server.SSEServer
⋮----
func (s *MCPServer) ServeStdio() error
⋮----
func main()
⋮----
var transport string
</file>

<file path="examples/everything/main.go">
package main
⋮----
import (
	"context"
	"flag"
	"fmt"
	"log"
	"time"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
)
⋮----
"context"
"flag"
"fmt"
"log"
"time"
⋮----
"github.com/mark3labs/mcp-go/mcp"
"github.com/mark3labs/mcp-go/server"
⋮----
type ToolName string
⋮----
const (
	ECHO                   ToolName = "echo"
	ADD                    ToolName = "add"
	LONG_RUNNING_OPERATION ToolName = "longRunningOperation"
	SAMPLE_LLM             ToolName = "sampleLLM"
	GET_TINY_IMAGE         ToolName = "getTinyImage"
)
⋮----
type PromptName string
⋮----
const (
	SIMPLE  PromptName = "simple_prompt"
	COMPLEX PromptName = "complex_prompt"
)
⋮----
func NewMCPServer() *server.MCPServer
⋮----
// s.server.AddTool(mcp.Tool{
// 	Name:        string(SAMPLE_LLM),
// 	Description: "Samples from an LLM using MCP's sampling feature",
// 	InputSchema: mcp.ToolInputSchema{
// 		Type: "object",
// 		Properties: map[string]interface{}{
// 			"prompt": map[string]interface{}{
// 				"type":        "string",
// 				"description": "The prompt to send to the LLM",
// 			},
// 			"maxTokens": map[string]interface{}{
// 				"type":        "number",
// 				"description": "Maximum number of tokens to generate",
// 				"default":     100,
⋮----
// 		},
// 	},
// }, s.handleSampleLLMTool)
⋮----
func generateResources() []mcp.Resource
⋮----
func runUpdateInterval()
⋮----
// for range s.updateTicker.C {
// 	for uri := range s.subscriptions {
// 		s.server.HandleMessage(
// 			context.Background(),
// 			mcp.JSONRPCNotification{
// 				JSONRPC: mcp.JSONRPC_VERSION,
// 				Notification: mcp.Notification{
// 					Method: "resources/updated",
// 					Params: struct {
// 						Meta map[string]interface{} `json:"_meta,omitempty"`
// 					}{
// 						Meta: map[string]interface{}{"uri": uri},
// 					},
// 				},
⋮----
// 		)
// 	}
// }
⋮----
func handleReadResource(
	ctx context.Context,
	request mcp.ReadResourceRequest,
) ([]mcp.ResourceContents, error)
⋮----
func handleResourceTemplate(
	ctx context.Context,
	request mcp.ReadResourceRequest,
) ([]mcp.ResourceContents, error)
⋮----
func handleSimplePrompt(
	ctx context.Context,
	request mcp.GetPromptRequest,
) (*mcp.GetPromptResult, error)
⋮----
func handleComplexPrompt(
	ctx context.Context,
	request mcp.GetPromptRequest,
) (*mcp.GetPromptResult, error)
⋮----
func handleEchoTool(
	ctx context.Context,
	request mcp.CallToolRequest,
) (*mcp.CallToolResult, error)
⋮----
func handleAddTool(
	ctx context.Context,
	request mcp.CallToolRequest,
) (*mcp.CallToolResult, error)
⋮----
func handleSendNotification(
	ctx context.Context,
	request mcp.CallToolRequest,
) (*mcp.CallToolResult, error)
⋮----
func handleLongRunningOperationTool(
	ctx context.Context,
	request mcp.CallToolRequest,
) (*mcp.CallToolResult, error)
⋮----
// func (s *MCPServer) handleSampleLLMTool(arguments map[string]interface{}) (*mcp.CallToolResult, error) {
// 	prompt, _ := arguments["prompt"].(string)
// 	maxTokens, _ := arguments["maxTokens"].(float64)
⋮----
// 	// This is a mock implementation. In a real scenario, you would use the server's RequestSampling method.
// 	result := fmt.Sprintf(
// 		"Sample LLM result for prompt: '%s' (max tokens: %d)",
// 		prompt,
// 		int(maxTokens),
// 	)
⋮----
// 	return &mcp.CallToolResult{
// 		Content: []interface{}{
// 			mcp.TextContent{
// 				Type: "text",
// 				Text: fmt.Sprintf("LLM sampling result: %s", result),
// 			},
// 		},
// 	}, nil
// }
⋮----
func handleGetTinyImageTool(
	ctx context.Context,
	request mcp.CallToolRequest,
) (*mcp.CallToolResult, error)
⋮----
func handleNotification(
	ctx context.Context,
	notification mcp.JSONRPCNotification,
)
⋮----
func main()
⋮----
var transport string
⋮----
// Only check for "sse" since stdio is the default
⋮----
const MCP_TINY_IMAGE = "iVBORw0KGgoAAAANSUhEUgAAARgAAAEYCAIAAAAI7H7bAAAZyUlEQVR4nOzce1RVZd4H8MM5BwERQUDxQpCoI0RajDWjomSEkOaltDBvaaIVy5aJltNkadkSdXJoWs6IKZko6bh0aABXxDTCKFgwgwalOKCICiJyEY7cz+Fw3rV63nnWb/a5eNSfWNP389fZt2dvNvu797Of5zlHazKZVABwZ9T3+gAA/hcgSAAMECQABggSAAMECYABggTAAEECYIAgATBAkAAYIEgADBAkAAYIEgADBAmAAYIEwABBAmCAIAEwQJAAGCBIAAwQJAAGCBIAAwQJgAGCBMAAQQJggCABMECQABggSAAMECQABggSAAMECYABggTAAEECYIAgATBAkAAYIEgADBAkAAYIEgADBAmAAYIEwABBAmCAIAEwQJAAGCBIAAwQJAAGCBIAAwQJgAGCBMAAQQJggCABMECQABggSAAMECQABggSAAMECYABggTAAEECYIAgATBAkAAYIEgADBAkAAYIEgADBAmAAYIEwABBAmCAIAEwQJAAGCBIAAwQJAAGCBIAAwQJgAGCBMAAQQJggCABMECQABggSAAMECQABggSAAMECYABggTAAEECYIAgATBAkAAYIEgADBAkAAYIEgADBAmAAYIEwABBAmCAIAEwQJAAGCBIAAwQJAAGCBIAAwQJgAGCBMAAQQJggCABMECQABggSAAMECQABggSAAMECYABggTAAEECYIAgATBAkAAYIEgADBAkAAYIEgADBAmAAYIEwABBAmCAIAEwQJAAGCBIAAwQJAAGCBIAAwQJgAGCBMAAQQJggCABMECQABho7/UBwM9L9w9M/43OkZ/FyhaXqlQqOp+uJrYy/qCrq0t87urqMhqN3d3dKpWq6wdiUi7t6uoSJZhvJRaZTCYxKTY0Go0eHh7Lly/v06eP+LsQpJ8vcZUYDAb9D8SFJSfF5SU+GwwGcQnq/0NuaDAYxIaKRWKp0Wg0mUzyYqUXrtFoFBe9nJRXv7hY5YaKRWJDOikS0pO8vLwyMzNlin56QZJ3I4vzzT/f6srimuj6D/n/MxgM8o5lMBjkZSEW0f863Zbe6hRligLpYciixFJ6uSgORnH7VCxSXLt0qVikOI2KU2r/pO01/1e5uLjMmzfv9ddfDwwMpPNvEiSDwXD06FHxH6VPUvn0lB/kv5Y+VcUFJK8zuYjebGSB9FYkZtLHtETLNH+I04ORZcrjlI9p82sL4Kaio6O3bNly//33my9ysH0Z1dTUxMTEqNU/yTaJn25C5EvCT9FP8chNJtPx48fb29utrTB06NCdO3eGh4dby8JNggTwP6+qqiomJuZvf/ubxaWPPvro8uXLZ82a5ebmZqMQBAl+7gIDA0tLSy0uCgsLy8zM7N27900LuQeNDTdu3MjMzJQtLR4eHlFRUTZqj2fPni0qKpKTwcHBo0ePtlH+lStXjh8/Lic1Gk10dLT5arm5uVVVVXSORqNxc3Pr06ePn5/foEGDevXqZb6V0WhMT0/v6OgQk0OGDAkLC1Oso9Ppjhw5Qv8iT0/P8PBwR0dHa8eclpbW1tYmPvfv33/s2LEZGRly6YMPPujp6fmPf/xDlGkymcLCwnx9fS0WlZWVdf36dfG5X79+UVFRDg4O1vZrrrKyMjc3V27i4uIyc+ZMRQnl5eUFBQWKmQ4ODq6urgEBAQMGDPD09NRoNNZ20dTUdObMmbNnzzY3N6vVam9v7+Dg4GHDhtm+5d8NV69enTt3rsUUOTs7L1u2bPPmzfakSCWr4z3pz3/+Mz2A3r17NzU12Vj/4YcfpuuvXLnSdvnLli1T/I0Wyx8/fry1c6LVah944IHt27eLpgiqpqaG/r9feeUVxQrXr18fO3YsLS0sLOzSpUs2Dri7u5tmbM6cOTk5ObSEHTt2fPzxx3RObm6uxaLa2tqGDh0qV4uIiLB9rsw9++yzdEdubm7Xrl1TrPPuu+9av6BU7u7uoaGhOTk55oXX1dWtXr16wIAB5lv5+vrOnDkzNTX1Vg/49uh0ui1btgwcOND8SNzc3F566aVvv/32lgq8B0GaP3++4tDfeusti2saDIYZM2YoVl66dKmNwqurq81vbNnZ2eZrenh42LgahKCgoJMnT9KtioqK6KPm97//PV3a0tLy+OOP0xIee+yx9vZ22yekvLycbvLOO+8kJSXROcePH3/99dflpIuLy4ULFywWVVdX5+zsLNc0z7ltaWlpTk5OdNdqtVpxBkwm0+LFi2966lQqVXJyMt3q0KFDFh/yVGBgoJ2HKvoPbk9JScmDDz5ovne1Wj1lypSKiorbKLOng9TR0eHq6qr4A7Ra7Y0bN8xX3r17t/lfO3/+fBvl0wtO2rZtm+LZ0tDQQFcYOHBgSEjIiBEjzCskvr6+9fX1csMjR47QpWlpaXLRjRs3FCkKCwvT6XQ3PSepqal0q5SUlLVr18pJBweHqqoqWjv18vLq6OiwWNSZM2doUQkJCTfdu1RZWWnxDn3w4EHFmrQ26+joOGbMmJCQkFGjRilqQR4eHlevXhWbNDY2enl5KUr29vYeNGgQrSJOmzbNzqM1ryzYKSkpqW/fvuZ/ZkRERHp6+u2VaTKZerpdu6CgoLW1VTGzq6vr5MmT5isrKoGCfD+xaNeuXeYzKysr5WuDcOHCBTq5fPnyU6dOlZWVXblyZfv27XRRVVUVrWjR1yoHBwdaS/nDH/5A1+zVq1daWprF/5mC4ok0fPhwupe+ffv27t370qVLco67u7viuSFdvnyZTvbv3/+me5fS09NramrM59Ndi569yspKOTly5MjCwsJTp05999139fX1Dz30kFzU1NT0/fffi89HjhyhNy8nJ6e///3vdXV11dXVjY2Nc+fOFc/5IUOG2Hm0t9clk5GRsXTp0hs3bijmJyQkfPXVV9OnT7+NMv//eG57y9ujqP1L5kEqLy+nbQaSeQ6lzMxMnU5nPv/ixYvV1dWKwunkyJEjxQcfH5/Y2Njk5GR6mzxx4oT8TC9xJycncaW2trZu3Lhx8+bNclGfPn1SUlLsqT2qVKpr167RyYCAAHq0Xl5ezs7O9Gr28/OzVpTiorexprk9e/ZYnE9jI16qr1y5IifpK5mLi0tSUpKLi4v5tt9++y0tJDEx8YknnhCf3d3d9+/f/80336xduzYkJMT+A74l1dXVa9asmTdvnmK+v7//3r174+Li7nQHt/0suz1jxoyxeBjTp09XrDl37lyLa44fP97iY12v10dFRYl1evXqtXTpUlmHDAkJ+fzzz+nK7733Hi2zvLycLm1qaqL1EHpsCxculPP79evX0dHR2dk5c+ZMWlpoaGhNTY395+Spp56S2/r6+nZ0dDzwwANyzoQJE1paWmj5sbGx1op644036Jq1tbV2HgNtJHR1dX3sscfk5BNPPEHXVNyD3nzzTbq0sbFx8ODBcunu3bvFfEUbxvnz5+0/P3cuJyfHx8dHcSE5ODjExcXZU/e2R48+kSoqKmglnr5RFBcX00dNUVGRrNc5ODj88pe/lIvE25R54cnJybJPbdKkSQkJCTJI1dXV//73v+nK58+fl5+9vLz8/f3p0s7Ozq6uLjlJx0SePXtWfhb1kEWLFqWlpcmZoaGhmZmZ5v82G2jz69NPP93W1qa45Z8+fZquHxAQYK0ouqa7u7udVTuj0ZiQkCAnn3rqKfoWpHiYFBcX00maeZVKdezYsbq6OvFZrVbLpf369aOrvfPOO3q93p5ju0MdHR3x8fGTJ0+mj/2+ffu+9957Op0uISHBnrq3PXo0SN9//718w9FoNDExMfLlvqqqqr6+Xq6ZkpIi03L//fdHRkbKRRbHceh0umXLlslNnn/+edEjJCYbGhoUdR5aXQkLC1N0iZw8eZJWEenlSMsJCAhISkqiL3IajebQoUO31B/S3NxM9zVx4sTOzk46x9fXV/EQoLUpBXqDGDZsmJ3HcO3atWPHjsnJ6dOn33fffXLy+vXr9L1UcTC0+ev06dMxMTFiqLhKpRowYIDsupCVZ+HAgQOKSsHdUFNTM3bs2LVr19LbokajycjIWLduHW+3VY8G6euvv5af3dzcpk2bJl+au7u75c2+oaGBNmQ9++yz9G9ubW01fyLRNgY3N7dZs2apVCpZx+jq6rp69Spdn77qPProoy0tLc3NzU1NTWfPnj18+PDy5cvpyrLi3traKm+3KpWqsbFx/fr1ctLR0fHAgQODBg26pXNSWloqbw0ajWbkyJH0caRSqQYNGqS4C9hICG1ssD9Ihw4dkk9dFxeXKVOmKB569HleW1tLF8XGxj72g5CQkIceeki2KKjV6jVr1sj/75w5cxSttfHx8ePHj09PT79LX4I4d+7ck08+qXh+jh49Oi8vz7wPnQFLBdFOdNjswoULFa8Ha9asEV2Kv/rVr+RMf3//+vr6+Ph4Oad37956vZ4W29LSQkuWrxBLliyRM4cPHy6Hfl+8eJG+Anl7ew/+gXn7rHgeNjQ0iA337t1r40y+/PLLt3FOduzYIRugBg8eXF1drdhLRkbGiy++SOdYa/tW5G39+vX2HEBLSwt95K5evdpkMinaPz7++GO5Pv2XWePo6Pjpp58qdrR3716LTW2zZ8+2/13OTsnJyYqWnqioqKysLGun7s71XJAUzcp//etfTSbThx9+KOeMGjXKZDK9//77cs6AAQPEWztdTbzD0JJTUlLkIq1WW1hYKOZv3LhRzler1eJRZjKZ0tPTbYzWkZydnadPn15WViZ3FBERIZdOnDhR0Wfl4eGhaLS4KYPBQNP+yCOPGAyGdevW0WLPnz9Ph0r4+flZKy0zM5Nu+Nlnn9lzDPTtyM3NTXRHGo1G2hK9atUqub6NiiXl5OT0ySefKPZ18eLFadOmmQ9ZCg4Orquru6VTZ01DQ0NsbCwtfODAgXaeijvRQ0G6fv06favz9fVta2szmUz03V2lUpWVldHX9E2bNonNd+7cSVdrbGykhdNq+qRJk+T8w4cP063y8/PFeBzbI1yExYsXK1qWOjo6aMf8q6++WldX98ILL9Ctxo0bd0sdhTqdjh78M888o2jg0mq1er2e9pNGRkZaK+2Pf/wjPRh7Brk0Njb+4he/kPtKTEyU3wd75ZVXZFFyqFFzczP9Pz7++OMH/yM5OfmNN96gh6pWq8XtkjIajZ999hl9BxNCQ0NlleG2bdiwgR5eUFBQYmIiV0Rt66EgffHFF/SxvmnTJvEPa2lpcXd3l/NjYmLkZycnJ3kpK2o7ly9fliUXFBTQRX/605/kIkVz0549e0wmU2dnJ71S3d3dJ02aFBoaquiVd3V1VVQgKyoq6LiHDRs2GI3GsrIyxf3VfByADbW1tbTMFStWmEwm2pciarb0FNkYIfX222/TIzEfI2cuMTFRrq941iUnJ8tFw4YNEzMvXLhAhyDRJ5VQUlJCL+WpU6da3O+lS5cUzWUODg4bNmyw77RZRisgokmmpaXlTgq8JT3U2FBYWCjfKd3c3KZOnSquP2dnZ/qVXRqYsLAw+bqs6Mhvbm6Wnz/99FO6qLi4+M3/+OSTT+iiiooKlUql1+tpG3FEREROTk5eXt7ly5cnT54s54s+Vrr55cuX6WuxGHw9YsQIRUVi69atnZ2ddp6W+vp68ZVyQdSm6KiLgICA+vp62mjm7e1trTTaFOnp6Wlt9INUVVX1m9/8Rk46Ozu//fbb8uzR7+fodDrRxlBbW0ubrc07fIOCgjIzM+VNMzs7u6mpyXzXfn5+2dnZ9KXfZDLt27evsbHR9jFbZDQaP/jgA1nR0Gg0S5Ysyc/PNx+Mdhf1QFi7urroUGta+zKZTCtWrLB4YN99951cRzHCLS8vT8z/17/+ZX8/wKxZs8SoVjpTtHAINTU1np6ecpGXl1dpaalcqkisPIbm5mbF1/ftv7P+5S9/oRseOHBA0d+1cuXK7OxsOsf8xUOaOHGiXG3UqFGKJ6q5l19+2c5T16tXLzEO7dChQ3T+l19+abFkWsHbsWOHtQMwGo206UKj0RQXF9t56qRz587JjnitVhsdHV1QUHCrhdy5nngi1dbW/vOf/5STimafCRMmmL99Pv/88/TlQXFrEfetxsbG+fPnm4+bskZ8qUnx5RP66uzj47No0SLa+/TMM8/IbmLxQBPUarXsw+3Tp8+uXbvo7X/9+vUfffSRPa26ioMJDAz8/PPP6ZyAgADFsEBrvbHt7e30HnHffffZblCpqqrat2/fTY9Q0Ov1X3/9dXd397lz5+RMrVZr/qoj2sppE7mNEd9qtdrat6rs0dLSsmrVqhEjRmRlZalUqvDw8MLCwoMHD9JW3x7TE1/sS01NpT1izz33HF0aGhrq5OREay8uLi5r1qyh6VK8wIggJSYmlpWVyZkrV66cMGGCoospKSlJnGWRZ51OpxgfLV+1hVdffbWpqUk+fEpKSrZt2/bmm28q+jq9vb1p19aECRNOnjw5efJk0VtlMpni4uJcXV2XLl1q+8zQ4xe9lornc2BgoPjxGcHJyYkOwKFaW1tpkIYPH2571zt37pRfJXR0dNy6dauiZLVavWXLFnkHzM7Obm9vp3eTvn37mh/MF198sWjRInkTcXV1nTNnjtFoNB9WbzAYkpKS9u/fL+f4+/vb3wtXXl7+3HPPiddgHx+fjz76aPbs2VrtPftVrJ7YMe01HzJkiGI8zuDBgwMCAkpKSuSc6OhoxeBFOg5SviPRTtj+/fsrmsiFU6dOySDp9frq6mpFf6LiF2ECAgIWLlxIa3H79u0TQaJdK/369VMcUnBw8IoVK37729+KSZPJtGnTpsWLF9v+19JRAh4eHkajUTH+2s/Pj3YBOzs7W3tHam1tpWM+KisrLQ6El4dHX0eHDBlisYKdlZUlg1RUVNTZ2UkPz9HR8cqVK7Jru62tLSUlZdu2bbSEMWPGVFRUdHR0ODs76/X6zs7O7u5uJycnvV6/atWq/Px8unJUVFR+fn5tbW1MTExkZORrr70WGRn5/vvvZ2RkzJ8/n3Y2XLp0KTw8XPQ+BwcHp6amKm6I98Ddrjvq9Xr6v3/xxRfN16F1jGHDhskOH0lRBdq8eXNeXh6dQ191KEWL8NGjRxcsWEDnKLqkxBsdHROg1WqLi4v1ev2oUaPkzHHjxpnvq7a2VnFDVXztzxxdX1xz9Fz17t372rVrtPNq4MCB1tqIc3Nzb+Xf/l/i4uIslqnoJzhz5gz9lgSvkJAQnU73u9/97uDBg6J6cuzYsfj4+NWrV+fk5BQVFcmjio+PF52tPj4+u3btMr9a7om7HqScnBxaSTPvWBDkqIIDBw6YL1X8uMK6deto/dDZ2dnaaOIvv/ySbrh79276ew/+/v4Wt1L0HcfGxup0OtpTPm/ePIsbKrpEXVxcTp8+be3MKL4PsmTJkhMnTtBOgtDQ0JaWFtoxOnbsWGulKb6Lbj+tViu/fqeg+GJlSkqK4jnMZfTo0eIYXnrppdLS0uLiYrVaffXq1V//+tfiZwLE92EbGhrEC3avXr0WLFhAv3B5z931xgbR2iM+9+nTZ9y4cRZXmzJlimg8ffrpp82XKt6RCgoK6IDr8PBwa+PKFJX4oqIi2ixm7UdU5s6dS4cL7dmzp6SkhDbjWvyJQJVK9eSTT7722mtysr29feHChdaGOSve1oYOHXr+/HnaRPHwww8rvvwTFBRksSgxtMzaItvmzZtn8Yux5iNNs7KybPzy220QnXjbt28/ceKEOIby8vIPP/xQ9G5t3LgxODj4hRdeWLx4cUVFRV5e3iOPPPLVV1+99dZbpaWl+/btszik61656z/HJX6G9/935uBgrQ1H/OipWq221tZko3NGo9FYexURdUs5qVar6ZVqY3ei7VhOarVag8EgH61ardbar+SIn8+mc6z15yjWFH8CbZURe+no6JD7tfGX0vN8S+w/ew4ODFeLqDzLv06j0dCHsDjtckdardZoNDo4OOTm5s6YMaO1tfXw4cOzZ8++w2O4G/C7dvCj1tbW9u67737wwQdBQUFbt26dOnXqvT4iy35iP6IPPysVFRXR0dFarTYtLS0iIsLen5i7F36SP+oNPwepqamRkZELFiz45ptvZsyY8WNOEZ5I8GOUn58fFxcXGBiYl5d3S1/av4fwjgQ/LhcvXoyIiNi/f/89Gelz2/BEgh+XwsLCo0ePKoa//PjhiQTAAI0NAAwQJAAGCBIAAwQJgAGCBMAAQQJggCABMECQABggSAAMECQABggSAAMECYABggTAAEECYIAgATBAkAAYIEgADBAkAAYIEgADBAmAAYIEwABBAmCAIAEwQJAAGCBIAAwQJAAGCBIAAwQJgAGCBMAAQQJggCABMECQABggSAAMECQABggSAAMECYABggTAAEECYIAgATBAkAAYIEgADBAkAAYIEgADBAmAAYIEwABBAmCAIAEwQJAAGCBIAAwQJAAGCBIAAwQJgAGCBMAAQQJggCABMECQABggSAAMECQABggSAAMECYABggTAAEECYIAgATBAkAAYIEgADBAkAAYIEgADBAmAAYIEwABBAmCAIAEwQJAAGCBIAAwQJAAGCBIAAwQJgAGCBMAAQQJggCABMECQABggSAAMECQABggSAAMECYABggTAAEECYIAgATBAkAAYIEgADBAkAAYIEgADBAmAAYIEwABBAmCAIAEwQJAAGCBIAAwQJAAGCBIAAwQJgAGCBMAAQQJggCABMECQABggSAAMECQABggSAAMECYABggTAAEECYIAgATBAkAAYIEgADBAkAAYIEgADBAmAAYIEwABBAmCAIAEwQJAAGCBIAAz+LwAA///FzJto8JNVBwAAAABJRU5ErkJggg=="
</file>

<file path="examples/filesystem_stdio_client/main.go">
package main
⋮----
import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"github.com/mark3labs/mcp-go/client"
	"github.com/mark3labs/mcp-go/mcp"
)
⋮----
"context"
"encoding/json"
"fmt"
"log"
"time"
⋮----
"github.com/mark3labs/mcp-go/client"
"github.com/mark3labs/mcp-go/mcp"
⋮----
func main()
⋮----
[]string{}, // Empty ENV
⋮----
// Create context with timeout
⋮----
// Initialize the client
⋮----
// List Tools
⋮----
// List allowed directories
⋮----
// List /tmp
⋮----
// Create mcp directory
⋮----
// Create hello.txt
⋮----
// Verify file contents
⋮----
// Get file info
⋮----
// Helper function to print tool results
func printToolResult(result *mcp.CallToolResult)
</file>

<file path="mcp/prompts.go">
package mcp
⋮----
/* Prompts */
⋮----
// ListPromptsRequest is sent from the client to request a list of prompts and
// prompt templates the server has.
type ListPromptsRequest struct {
	PaginatedRequest
}
⋮----
// ListPromptsResult is the server's response to a prompts/list request from
// the client.
type ListPromptsResult struct {
	PaginatedResult
	Prompts []Prompt `json:"prompts"`
}
⋮----
// GetPromptRequest is used by the client to get a prompt provided by the
// server.
type GetPromptRequest struct {
	Request
	Params struct {
		// The name of the prompt or prompt template.
		Name string `json:"name"`
		// Arguments to use for templating the prompt.
		Arguments map[string]string `json:"arguments,omitempty"`
	} `json:"params"`
⋮----
// The name of the prompt or prompt template.
⋮----
// Arguments to use for templating the prompt.
⋮----
// GetPromptResult is the server's response to a prompts/get request from the
// client.
type GetPromptResult struct {
	Result
	// An optional description for the prompt.
	Description string          `json:"description,omitempty"`
	Messages    []PromptMessage `json:"messages"`
}
⋮----
// An optional description for the prompt.
⋮----
// Prompt represents a prompt or prompt template that the server offers.
// If Arguments is non-nil and non-empty, this indicates the prompt is a template
// that requires argument values to be provided when calling prompts/get.
// If Arguments is nil or empty, this is a static prompt that takes no arguments.
type Prompt struct {
	// The name of the prompt or prompt template.
	Name string `json:"name"`
	// An optional description of what this prompt provides
	Description string `json:"description,omitempty"`
	// A list of arguments to use for templating the prompt.
	// The presence of arguments indicates this is a template prompt.
	Arguments []PromptArgument `json:"arguments,omitempty"`
}
⋮----
// The name of the prompt or prompt template.
⋮----
// An optional description of what this prompt provides
⋮----
// A list of arguments to use for templating the prompt.
// The presence of arguments indicates this is a template prompt.
⋮----
// PromptArgument describes an argument that a prompt template can accept.
// When a prompt includes arguments, clients must provide values for all
// required arguments when making a prompts/get request.
type PromptArgument struct {
	// The name of the argument.
	Name string `json:"name"`
	// A human-readable description of the argument.
	Description string `json:"description,omitempty"`
	// Whether this argument must be provided.
	// If true, clients must include this argument when calling prompts/get.
	Required bool `json:"required,omitempty"`
}
⋮----
// The name of the argument.
⋮----
// A human-readable description of the argument.
⋮----
// Whether this argument must be provided.
// If true, clients must include this argument when calling prompts/get.
⋮----
// Role represents the sender or recipient of messages and data in a
// conversation.
type Role string
⋮----
const (
	RoleUser      Role = "user"
	RoleAssistant Role = "assistant"
)
⋮----
// PromptMessage describes a message returned as part of a prompt.
//
// This is similar to `SamplingMessage`, but also supports the embedding of
// resources from the MCP server.
type PromptMessage struct {
	Role    Role    `json:"role"`
	Content Content `json:"content"` // Can be TextContent, ImageContent, or EmbeddedResource
}
⋮----
Content Content `json:"content"` // Can be TextContent, ImageContent, or EmbeddedResource
⋮----
// PromptListChangedNotification is an optional notification from the server
// to the client, informing it that the list of prompts it offers has changed. This
// may be issued by servers without any previous subscription from the client.
type PromptListChangedNotification struct {
	Notification
}
⋮----
// PromptOption is a function that configures a Prompt.
// It provides a flexible way to set various properties of a Prompt using the functional options pattern.
type PromptOption func(*Prompt)
⋮----
// ArgumentOption is a function that configures a PromptArgument.
// It allows for flexible configuration of prompt arguments using the functional options pattern.
type ArgumentOption func(*PromptArgument)
⋮----
// Core Prompt Functions
⋮----
// NewPrompt creates a new Prompt with the given name and options.
// The prompt will be configured based on the provided options.
// Options are applied in order, allowing for flexible prompt configuration.
func NewPrompt(name string, opts ...PromptOption) Prompt
⋮----
// WithPromptDescription adds a description to the Prompt.
// The description should provide a clear, human-readable explanation of what the prompt does.
func WithPromptDescription(description string) PromptOption
⋮----
// WithArgument adds an argument to the prompt's argument list.
// The argument will be configured based on the provided options.
func WithArgument(name string, opts ...ArgumentOption) PromptOption
⋮----
// Argument Options
⋮----
// ArgumentDescription adds a description to a prompt argument.
// The description should explain the purpose and expected values of the argument.
func ArgumentDescription(desc string) ArgumentOption
⋮----
// RequiredArgument marks an argument as required in the prompt.
// Required arguments must be provided when getting the prompt.
func RequiredArgument() ArgumentOption
</file>

<file path="mcp/resources.go">
package mcp
⋮----
import "github.com/yosida95/uritemplate/v3"
⋮----
// ResourceOption is a function that configures a Resource.
// It provides a flexible way to set various properties of a Resource using the functional options pattern.
type ResourceOption func(*Resource)
⋮----
// NewResource creates a new Resource with the given URI, name and options.
// The resource will be configured based on the provided options.
// Options are applied in order, allowing for flexible resource configuration.
func NewResource(uri string, name string, opts ...ResourceOption) Resource
⋮----
// WithResourceDescription adds a description to the Resource.
// The description should provide a clear, human-readable explanation of what the resource represents.
func WithResourceDescription(description string) ResourceOption
⋮----
// WithMIMEType sets the MIME type for the Resource.
// This should indicate the format of the resource's contents.
func WithMIMEType(mimeType string) ResourceOption
⋮----
// WithAnnotations adds annotations to the Resource.
// Annotations can provide additional metadata about the resource's intended use.
func WithAnnotations(audience []Role, priority float64) ResourceOption
⋮----
// ResourceTemplateOption is a function that configures a ResourceTemplate.
// It provides a flexible way to set various properties of a ResourceTemplate using the functional options pattern.
type ResourceTemplateOption func(*ResourceTemplate)
⋮----
// NewResourceTemplate creates a new ResourceTemplate with the given URI template, name and options.
// The template will be configured based on the provided options.
// Options are applied in order, allowing for flexible template configuration.
func NewResourceTemplate(uriTemplate string, name string, opts ...ResourceTemplateOption) ResourceTemplate
⋮----
// WithTemplateDescription adds a description to the ResourceTemplate.
// The description should provide a clear, human-readable explanation of what resources this template represents.
func WithTemplateDescription(description string) ResourceTemplateOption
⋮----
// WithTemplateMIMEType sets the MIME type for the ResourceTemplate.
// This should only be set if all resources matching this template will have the same type.
func WithTemplateMIMEType(mimeType string) ResourceTemplateOption
⋮----
// WithTemplateAnnotations adds annotations to the ResourceTemplate.
// Annotations can provide additional metadata about the template's intended use.
func WithTemplateAnnotations(audience []Role, priority float64) ResourceTemplateOption
</file>

<file path="mcp/tools_test.go">
package mcp
⋮----
import (
	"encoding/json"
	"testing"

	"github.com/stretchr/testify/assert"
)
⋮----
"encoding/json"
"testing"
⋮----
"github.com/stretchr/testify/assert"
⋮----
// TestToolWithBothSchemasError verifies that there will be feedback if the
// developer mixes raw schema with a schema provided via DSL.
func TestToolWithBothSchemasError(t *testing.T)
⋮----
// Create a tool with both schemas set
⋮----
// Set the RawInputSchema as well - this should conflict with the InputSchema
// Note: InputSchema.Type is explicitly set to "object" in NewTool
⋮----
// Attempt to marshal to JSON
⋮----
// Should return an error
⋮----
func TestToolWithRawSchema(t *testing.T)
⋮----
// Create a complex raw schema
⋮----
// Create a tool with raw schema
⋮----
// Marshal to JSON
⋮----
// Unmarshal to verify the structure
var result map[string]interface{}
⋮----
// Verify tool properties
⋮----
// Verify schema was properly included
⋮----
func TestUnmarshalToolWithRawSchema(t *testing.T)
⋮----
var toolUnmarshalled Tool
⋮----
func TestUnmarshalToolWithoutRawSchema(t *testing.T)
⋮----
func TestToolWithObjectAndArray(t *testing.T)
⋮----
// Create a tool with both object and array properties
⋮----
// Verify properties
⋮----
// Verify preferences object
⋮----
// Verify books array
⋮----
// Verify array items schema
⋮----
// Verify required fields
</file>

<file path="mcp/tools.go">
package mcp
⋮----
import (
	"encoding/json"
	"errors"
	"fmt"
)
⋮----
"encoding/json"
"errors"
"fmt"
⋮----
var errToolSchemaConflict = errors.New("provide either InputSchema or RawInputSchema, not both")
⋮----
// ListToolsRequest is sent from the client to request a list of tools the
// server has.
type ListToolsRequest struct {
	PaginatedRequest
}
⋮----
// ListToolsResult is the server's response to a tools/list request from the
// client.
type ListToolsResult struct {
	PaginatedResult
	Tools []Tool `json:"tools"`
}
⋮----
// CallToolResult is the server's response to a tool call.
//
// Any errors that originate from the tool SHOULD be reported inside the result
// object, with `isError` set to true, _not_ as an MCP protocol-level error
// response. Otherwise, the LLM would not be able to see that an error occurred
// and self-correct.
⋮----
// However, any errors in _finding_ the tool, an error indicating that the
// server does not support tool calls, or any other exceptional conditions,
// should be reported as an MCP error response.
type CallToolResult struct {
	Result
	Content []Content `json:"content"` // Can be TextContent, ImageContent, or      EmbeddedResource
	// Whether the tool call ended in an error.
	//
	// If not set, this is assumed to be false (the call was successful).
	IsError bool `json:"isError,omitempty"`
}
⋮----
Content []Content `json:"content"` // Can be TextContent, ImageContent, or      EmbeddedResource
// Whether the tool call ended in an error.
//
// If not set, this is assumed to be false (the call was successful).
⋮----
// CallToolRequest is used by the client to invoke a tool provided by the server.
type CallToolRequest struct {
	Request
	Params struct {
		Name      string                 `json:"name"`
		Arguments map[string]interface{} `json:"arguments,omitempty"`
⋮----
// If specified, the caller is requesting out-of-band progress
// notifications for this request (as represented by
// notifications/progress). The value of this parameter is an
// opaque token that will be attached to any subsequent
// notifications. The receiver is not obligated to provide these
// notifications.
⋮----
// ToolListChangedNotification is an optional notification from the server to
// the client, informing it that the list of tools it offers has changed. This may
// be issued by servers without any previous subscription from the client.
type ToolListChangedNotification struct {
	Notification
}
⋮----
// Tool represents the definition for a tool the client can call.
type Tool struct {
	// The name of the tool.
	Name string `json:"name"`
	// A human-readable description of the tool.
	Description string `json:"description,omitempty"`
	// A JSON Schema object defining the expected parameters for the tool.
	InputSchema ToolInputSchema `json:"inputSchema"`
	// Alternative to InputSchema - allows arbitrary JSON Schema to be provided
	RawInputSchema json.RawMessage `json:"-"` // Hide this from JSON marshaling
}
⋮----
// The name of the tool.
⋮----
// A human-readable description of the tool.
⋮----
// A JSON Schema object defining the expected parameters for the tool.
⋮----
// Alternative to InputSchema - allows arbitrary JSON Schema to be provided
RawInputSchema json.RawMessage `json:"-"` // Hide this from JSON marshaling
⋮----
// MarshalJSON implements the json.Marshaler interface for Tool.
// It handles marshaling either InputSchema or RawInputSchema based on which is set.
func (t Tool) MarshalJSON() ([]byte, error)
⋮----
// Create a map to build the JSON structure
⋮----
// Add the name and description
⋮----
// Determine which schema to use
⋮----
// Use the structured InputSchema
⋮----
type ToolInputSchema struct {
	Type       string                 `json:"type"`
	Properties map[string]interface{} `json:"properties"`
⋮----
// ToolOption is a function that configures a Tool.
// It provides a flexible way to set various properties of a Tool using the functional options pattern.
type ToolOption func(*Tool)
⋮----
// PropertyOption is a function that configures a property in a Tool's input schema.
// It allows for flexible configuration of JSON Schema properties using the functional options pattern.
type PropertyOption func(map[string]interface{})
⋮----
// Core Tool Functions
⋮----
// NewTool creates a new Tool with the given name and options.
// The tool will have an object-type input schema with configurable properties.
// Options are applied in order, allowing for flexible tool configuration.
func NewTool(name string, opts ...ToolOption) Tool
⋮----
Required:   nil, // Will be omitted from JSON if empty
⋮----
// NewToolWithRawSchema creates a new Tool with the given name and a raw JSON
// Schema. This allows for arbitrary JSON Schema to be used for the tool's input
// schema.
⋮----
// NOTE a [Tool] built in such a way is incompatible with the [ToolOption] and
// runtime errors will result from supplying a [ToolOption] to a [Tool] built
// with this function.
func NewToolWithRawSchema(name, description string, schema json.RawMessage) Tool
⋮----
// WithDescription adds a description to the Tool.
// The description should provide a clear, human-readable explanation of what the tool does.
func WithDescription(description string) ToolOption
⋮----
// Common Property Options
⋮----
// Description adds a description to a property in the JSON Schema.
// The description should explain the purpose and expected values of the property.
func Description(desc string) PropertyOption
⋮----
// Required marks a property as required in the tool's input schema.
// Required properties must be provided when using the tool.
func Required() PropertyOption
⋮----
// Title adds a display-friendly title to a property in the JSON Schema.
// This title can be used by UI components to show a more readable property name.
func Title(title string) PropertyOption
⋮----
// String Property Options
⋮----
// DefaultString sets the default value for a string property.
// This value will be used if the property is not explicitly provided.
func DefaultString(value string) PropertyOption
⋮----
// Enum specifies a list of allowed values for a string property.
// The property value must be one of the specified enum values.
func Enum(values ...string) PropertyOption
⋮----
// MaxLength sets the maximum length for a string property.
// The string value must not exceed this length.
func MaxLength(max int) PropertyOption
⋮----
// MinLength sets the minimum length for a string property.
// The string value must be at least this length.
func MinLength(min int) PropertyOption
⋮----
// Pattern sets a regex pattern that a string property must match.
// The string value must conform to the specified regular expression.
func Pattern(pattern string) PropertyOption
⋮----
// Number Property Options
⋮----
// DefaultNumber sets the default value for a number property.
⋮----
func DefaultNumber(value float64) PropertyOption
⋮----
// Max sets the maximum value for a number property.
// The number value must not exceed this maximum.
func Max(max float64) PropertyOption
⋮----
// Min sets the minimum value for a number property.
// The number value must not be less than this minimum.
func Min(min float64) PropertyOption
⋮----
// MultipleOf specifies that a number must be a multiple of the given value.
// The number value must be divisible by this value.
func MultipleOf(value float64) PropertyOption
⋮----
// Boolean Property Options
⋮----
// DefaultBool sets the default value for a boolean property.
⋮----
func DefaultBool(value bool) PropertyOption
⋮----
// Property Type Helpers
⋮----
// WithBoolean adds a boolean property to the tool schema.
// It accepts property options to configure the boolean property's behavior and constraints.
func WithBoolean(name string, opts ...PropertyOption) ToolOption
⋮----
// Remove required from property schema and add to InputSchema.required
⋮----
// WithNumber adds a number property to the tool schema.
// It accepts property options to configure the number property's behavior and constraints.
func WithNumber(name string, opts ...PropertyOption) ToolOption
⋮----
// WithString adds a string property to the tool schema.
// It accepts property options to configure the string property's behavior and constraints.
func WithString(name string, opts ...PropertyOption) ToolOption
⋮----
// WithObject adds an object property to the tool schema.
// It accepts property options to configure the object property's behavior and constraints.
func WithObject(name string, opts ...PropertyOption) ToolOption
⋮----
// WithArray adds an array property to the tool schema.
// It accepts property options to configure the array property's behavior and constraints.
func WithArray(name string, opts ...PropertyOption) ToolOption
⋮----
// Properties defines the properties for an object schema
func Properties(props map[string]interface
⋮----
// AdditionalProperties specifies whether additional properties are allowed in the object
// or defines a schema for additional properties
func AdditionalProperties(schema interface
⋮----
// MinProperties sets the minimum number of properties for an object
func MinProperties(min int) PropertyOption
⋮----
// MaxProperties sets the maximum number of properties for an object
func MaxProperties(max int) PropertyOption
⋮----
// PropertyNames defines a schema for property names in an object
func PropertyNames(schema map[string]interface
⋮----
// Items defines the schema for array items
func Items(schema interface
⋮----
// MinItems sets the minimum number of items for an array
func MinItems(min int) PropertyOption
⋮----
// MaxItems sets the maximum number of items for an array
func MaxItems(max int) PropertyOption
⋮----
// UniqueItems specifies whether array items must be unique
func UniqueItems(unique bool) PropertyOption
</file>

<file path="mcp/types.go">
// Package mcp defines the core types and interfaces for the Model Control Protocol (MCP).
// MCP is a protocol for communication between LLM-powered applications and their supporting services.
package mcp
⋮----
import (
	"encoding/json"

	"github.com/yosida95/uritemplate/v3"
)
⋮----
"encoding/json"
⋮----
"github.com/yosida95/uritemplate/v3"
⋮----
type MCPMethod string
⋮----
const (
	// Initiates connection and negotiates protocol capabilities.
	// https://spec.modelcontextprotocol.io/specification/2024-11-05/basic/lifecycle/#initialization
	MethodInitialize MCPMethod = "initialize"

	// Verifies connection liveness between client and server.
	// https://spec.modelcontextprotocol.io/specification/2024-11-05/basic/utilities/ping/
	MethodPing MCPMethod = "ping"

	// Lists all available server resources.
	// https://spec.modelcontextprotocol.io/specification/2024-11-05/server/resources/
	MethodResourcesList MCPMethod = "resources/list"

	// Provides URI templates for constructing resource URIs.
	// https://spec.modelcontextprotocol.io/specification/2024-11-05/server/resources/
	MethodResourcesTemplatesList MCPMethod = "resources/templates/list"

	// Retrieves content of a specific resource by URI.
	// https://spec.modelcontextprotocol.io/specification/2024-11-05/server/resources/
	MethodResourcesRead MCPMethod = "resources/read"

	// Lists all available prompt templates.
	// https://spec.modelcontextprotocol.io/specification/2024-11-05/server/prompts/
	MethodPromptsList MCPMethod = "prompts/list"

	// Retrieves a specific prompt template with filled parameters.
	// https://spec.modelcontextprotocol.io/specification/2024-11-05/server/prompts/
	MethodPromptsGet MCPMethod = "prompts/get"

	// Lists all available executable tools.
	// https://spec.modelcontextprotocol.io/specification/2024-11-05/server/tools/
	MethodToolsList MCPMethod = "tools/list"

	// Invokes a specific tool with provided parameters.
	// https://spec.modelcontextprotocol.io/specification/2024-11-05/server/tools/
	MethodToolsCall MCPMethod = "tools/call"
)
⋮----
// Initiates connection and negotiates protocol capabilities.
// https://spec.modelcontextprotocol.io/specification/2024-11-05/basic/lifecycle/#initialization
⋮----
// Verifies connection liveness between client and server.
// https://spec.modelcontextprotocol.io/specification/2024-11-05/basic/utilities/ping/
⋮----
// Lists all available server resources.
// https://spec.modelcontextprotocol.io/specification/2024-11-05/server/resources/
⋮----
// Provides URI templates for constructing resource URIs.
⋮----
// Retrieves content of a specific resource by URI.
⋮----
// Lists all available prompt templates.
// https://spec.modelcontextprotocol.io/specification/2024-11-05/server/prompts/
⋮----
// Retrieves a specific prompt template with filled parameters.
⋮----
// Lists all available executable tools.
// https://spec.modelcontextprotocol.io/specification/2024-11-05/server/tools/
⋮----
// Invokes a specific tool with provided parameters.
⋮----
type URITemplate struct {
	*uritemplate.Template
}
⋮----
func (t *URITemplate) MarshalJSON() ([]byte, error)
⋮----
func (t *URITemplate) UnmarshalJSON(data []byte) error
⋮----
var raw string
⋮----
/* JSON-RPC types */
⋮----
// JSONRPCMessage represents either a JSONRPCRequest, JSONRPCNotification, JSONRPCResponse, or JSONRPCError
type JSONRPCMessage interface{}
⋮----
// LATEST_PROTOCOL_VERSION is the most recent version of the MCP protocol.
const LATEST_PROTOCOL_VERSION = "2024-11-05"
⋮----
// JSONRPC_VERSION is the version of JSON-RPC used by MCP.
const JSONRPC_VERSION = "2.0"
⋮----
// ProgressToken is used to associate progress notifications with the original request.
type ProgressToken interface{}
⋮----
// Cursor is an opaque token used to represent a cursor for pagination.
type Cursor string
⋮----
type Request struct {
	Method string `json:"method"`
	Params struct {
		Meta *struct {
			// If specified, the caller is requesting out-of-band progress
			// notifications for this request (as represented by
			// notifications/progress). The value of this parameter is an
			// opaque token that will be attached to any subsequent
			// notifications. The receiver is not obligated to provide these
			// notifications.
			ProgressToken ProgressToken `json:"progressToken,omitempty"`
		} `json:"_meta,omitempty"`
⋮----
// If specified, the caller is requesting out-of-band progress
// notifications for this request (as represented by
// notifications/progress). The value of this parameter is an
// opaque token that will be attached to any subsequent
// notifications. The receiver is not obligated to provide these
// notifications.
⋮----
type Params map[string]interface{}
⋮----
type Notification struct {
	Method string             `json:"method"`
	Params NotificationParams `json:"params,omitempty"`
}
⋮----
type NotificationParams struct {
	// This parameter name is reserved by MCP to allow clients and
	// servers to attach additional metadata to their notifications.
	Meta map[string]interface{} `json:"_meta,omitempty"`
⋮----
// This parameter name is reserved by MCP to allow clients and
// servers to attach additional metadata to their notifications.
⋮----
// Additional fields can be added to this map
⋮----
// MarshalJSON implements custom JSON marshaling
⋮----
// Create a map to hold all fields
⋮----
// Add Meta if it exists
⋮----
// Add all additional fields
⋮----
// Ensure we don't override the _meta field
⋮----
// UnmarshalJSON implements custom JSON unmarshaling
⋮----
var m map[string]interface{}
⋮----
// Initialize maps if they're nil
⋮----
// Process all fields
⋮----
// Handle Meta field
⋮----
// Handle additional fields
⋮----
type Result struct {
	// This result property is reserved by the protocol to allow clients and
	// servers to attach additional metadata to their responses.
	Meta map[string]interface{} `json:"_meta,omitempty"`
⋮----
// This result property is reserved by the protocol to allow clients and
// servers to attach additional metadata to their responses.
⋮----
// RequestId is a uniquely identifying ID for a request in JSON-RPC.
// It can be any JSON-serializable value, typically a number or string.
type RequestId interface{}
⋮----
// JSONRPCRequest represents a request that expects a response.
type JSONRPCRequest struct {
	JSONRPC string      `json:"jsonrpc"`
	ID      RequestId   `json:"id"`
	Params  interface{} `json:"params,omitempty"`
⋮----
// JSONRPCNotification represents a notification which does not expect a response.
type JSONRPCNotification struct {
	JSONRPC string `json:"jsonrpc"`
	Notification
}
⋮----
// JSONRPCResponse represents a successful (non-error) response to a request.
type JSONRPCResponse struct {
	JSONRPC string      `json:"jsonrpc"`
	ID      RequestId   `json:"id"`
	Result  interface{} `json:"result"`
⋮----
// JSONRPCError represents a non-successful (error) response to a request.
type JSONRPCError struct {
	JSONRPC string    `json:"jsonrpc"`
	ID      RequestId `json:"id"`
	Error   struct {
		// The error type that occurred.
		Code int `json:"code"`
		// A short description of the error. The message SHOULD be limited
		// to a concise single sentence.
		Message string `json:"message"`
		// Additional information about the error. The value of this member
		// is defined by the sender (e.g. detailed error information, nested errors etc.).
		Data interface{} `json:"data,omitempty"`
⋮----
// The error type that occurred.
⋮----
// A short description of the error. The message SHOULD be limited
// to a concise single sentence.
⋮----
// Additional information about the error. The value of this member
// is defined by the sender (e.g. detailed error information, nested errors etc.).
⋮----
// Standard JSON-RPC error codes
const (
	PARSE_ERROR      = -32700
	INVALID_REQUEST  = -32600
	METHOD_NOT_FOUND = -32601
	INVALID_PARAMS   = -32602
	INTERNAL_ERROR   = -32603
)
⋮----
/* Empty result */
⋮----
// EmptyResult represents a response that indicates success but carries no data.
type EmptyResult Result
⋮----
/* Cancellation */
⋮----
// CancelledNotification can be sent by either side to indicate that it is
// cancelling a previously-issued request.
//
// The request SHOULD still be in-flight, but due to communication latency, it
// is always possible that this notification MAY arrive after the request has
// already finished.
⋮----
// This notification indicates that the result will be unused, so any
// associated processing SHOULD cease.
⋮----
// A client MUST NOT attempt to cancel its `initialize` request.
type CancelledNotification struct {
	Notification
	Params struct {
		// The ID of the request to cancel.
		//
		// This MUST correspond to the ID of a request previously issued
		// in the same direction.
		RequestId RequestId `json:"requestId"`

		// An optional string describing the reason for the cancellation. This MAY
		// be logged or presented to the user.
		Reason string `json:"reason,omitempty"`
	} `json:"params"`
⋮----
// The ID of the request to cancel.
//
// This MUST correspond to the ID of a request previously issued
// in the same direction.
⋮----
// An optional string describing the reason for the cancellation. This MAY
// be logged or presented to the user.
⋮----
/* Initialization */
⋮----
// InitializeRequest is sent from the client to the server when it first
// connects, asking it to begin initialization.
type InitializeRequest struct {
	Request
	Params struct {
		// The latest version of the Model Context Protocol that the client supports.
		// The client MAY decide to support older versions as well.
		ProtocolVersion string             `json:"protocolVersion"`
		Capabilities    ClientCapabilities `json:"capabilities"`
		ClientInfo      Implementation     `json:"clientInfo"`
	} `json:"params"`
⋮----
// The latest version of the Model Context Protocol that the client supports.
// The client MAY decide to support older versions as well.
⋮----
// InitializeResult is sent after receiving an initialize request from the
// client.
type InitializeResult struct {
	Result
	// The version of the Model Context Protocol that the server wants to use.
	// This may not match the version that the client requested. If the client cannot
	// support this version, it MUST disconnect.
	ProtocolVersion string             `json:"protocolVersion"`
	Capabilities    ServerCapabilities `json:"capabilities"`
	ServerInfo      Implementation     `json:"serverInfo"`
	// Instructions describing how to use the server and its features.
	//
	// This can be used by clients to improve the LLM's understanding of
	// available tools, resources, etc. It can be thought of like a "hint" to the model.
	// For example, this information MAY be added to the system prompt.
	Instructions string `json:"instructions,omitempty"`
}
⋮----
// The version of the Model Context Protocol that the server wants to use.
// This may not match the version that the client requested. If the client cannot
// support this version, it MUST disconnect.
⋮----
// Instructions describing how to use the server and its features.
//
// This can be used by clients to improve the LLM's understanding of
// available tools, resources, etc. It can be thought of like a "hint" to the model.
// For example, this information MAY be added to the system prompt.
⋮----
// InitializedNotification is sent from the client to the server after
// initialization has finished.
type InitializedNotification struct {
	Notification
}
⋮----
// ClientCapabilities represents capabilities a client may support. Known
// capabilities are defined here, in this schema, but this is not a closed set: any
// client can define its own, additional capabilities.
type ClientCapabilities struct {
	// Experimental, non-standard capabilities that the client supports.
	Experimental map[string]interface{} `json:"experimental,omitempty"`
⋮----
// Experimental, non-standard capabilities that the client supports.
⋮----
// Present if the client supports listing roots.
⋮----
// Whether the client supports notifications for changes to the roots list.
⋮----
// Present if the client supports sampling from an LLM.
⋮----
// ServerCapabilities represents capabilities that a server may support. Known
⋮----
// server can define its own, additional capabilities.
type ServerCapabilities struct {
	// Experimental, non-standard capabilities that the server supports.
	Experimental map[string]interface{} `json:"experimental,omitempty"`
⋮----
// Experimental, non-standard capabilities that the server supports.
⋮----
// Present if the server supports sending log messages to the client.
⋮----
// Present if the server offers any prompt templates.
⋮----
// Whether this server supports notifications for changes to the prompt list.
⋮----
// Present if the server offers any resources to read.
⋮----
// Whether this server supports subscribing to resource updates.
⋮----
// Whether this server supports notifications for changes to the resource
// list.
⋮----
// Present if the server offers any tools to call.
⋮----
// Whether this server supports notifications for changes to the tool list.
⋮----
// Implementation describes the name and version of an MCP implementation.
type Implementation struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}
⋮----
/* Ping */
⋮----
// PingRequest represents a ping, issued by either the server or the client,
// to check that the other party is still alive. The receiver must promptly respond,
// or else may be disconnected.
type PingRequest struct {
	Request
}
⋮----
/* Progress notifications */
⋮----
// ProgressNotification is an out-of-band notification used to inform the
// receiver of a progress update for a long-running request.
type ProgressNotification struct {
	Notification
	Params struct {
		// The progress token which was given in the initial request, used to
		// associate this notification with the request that is proceeding.
		ProgressToken ProgressToken `json:"progressToken"`
		// The progress thus far. This should increase every time progress is made,
		// even if the total is unknown.
		Progress float64 `json:"progress"`
		// Total number of items to process (or total progress required), if known.
		Total float64 `json:"total,omitempty"`
	} `json:"params"`
⋮----
// The progress token which was given in the initial request, used to
// associate this notification with the request that is proceeding.
⋮----
// The progress thus far. This should increase every time progress is made,
// even if the total is unknown.
⋮----
// Total number of items to process (or total progress required), if known.
⋮----
/* Pagination */
⋮----
type PaginatedRequest struct {
	Request
	Params struct {
		// An opaque token representing the current pagination position.
		// If provided, the server should return results starting after this cursor.
		Cursor Cursor `json:"cursor,omitempty"`
	} `json:"params,omitempty"`
⋮----
// An opaque token representing the current pagination position.
// If provided, the server should return results starting after this cursor.
⋮----
type PaginatedResult struct {
	Result
	// An opaque token representing the pagination position after the last
	// returned result.
	// If present, there may be more results available.
	NextCursor Cursor `json:"nextCursor,omitempty"`
}
⋮----
// An opaque token representing the pagination position after the last
// returned result.
// If present, there may be more results available.
⋮----
/* Resources */
⋮----
// ListResourcesRequest is sent from the client to request a list of resources
// the server has.
type ListResourcesRequest struct {
	PaginatedRequest
}
⋮----
// ListResourcesResult is the server's response to a resources/list request
// from the client.
type ListResourcesResult struct {
	PaginatedResult
	Resources []Resource `json:"resources"`
}
⋮----
// ListResourceTemplatesRequest is sent from the client to request a list of
// resource templates the server has.
type ListResourceTemplatesRequest struct {
	PaginatedRequest
}
⋮----
// ListResourceTemplatesResult is the server's response to a
// resources/templates/list request from the client.
type ListResourceTemplatesResult struct {
	PaginatedResult
	ResourceTemplates []ResourceTemplate `json:"resourceTemplates"`
}
⋮----
// ReadResourceRequest is sent from the client to the server, to read a
// specific resource URI.
type ReadResourceRequest struct {
	Request
	Params struct {
		// The URI of the resource to read. The URI can use any protocol; it is up
		// to the server how to interpret it.
		URI string `json:"uri"`
		// Arguments to pass to the resource handler
		Arguments map[string]interface{} `json:"arguments,omitempty"`
⋮----
// The URI of the resource to read. The URI can use any protocol; it is up
// to the server how to interpret it.
⋮----
// Arguments to pass to the resource handler
⋮----
// ReadResourceResult is the server's response to a resources/read request
⋮----
type ReadResourceResult struct {
	Result
	Contents []ResourceContents `json:"contents"` // Can be TextResourceContents or BlobResourceContents
}
⋮----
Contents []ResourceContents `json:"contents"` // Can be TextResourceContents or BlobResourceContents
⋮----
// ResourceListChangedNotification is an optional notification from the server
// to the client, informing it that the list of resources it can read from has
// changed. This may be issued by servers without any previous subscription from
// the client.
type ResourceListChangedNotification struct {
	Notification
}
⋮----
// SubscribeRequest is sent from the client to request resources/updated
// notifications from the server whenever a particular resource changes.
type SubscribeRequest struct {
	Request
	Params struct {
		// The URI of the resource to subscribe to. The URI can use any protocol; it
		// is up to the server how to interpret it.
		URI string `json:"uri"`
	} `json:"params"`
⋮----
// The URI of the resource to subscribe to. The URI can use any protocol; it
// is up to the server how to interpret it.
⋮----
// UnsubscribeRequest is sent from the client to request cancellation of
// resources/updated notifications from the server. This should follow a previous
// resources/subscribe request.
type UnsubscribeRequest struct {
	Request
	Params struct {
		// The URI of the resource to unsubscribe from.
		URI string `json:"uri"`
	} `json:"params"`
⋮----
// The URI of the resource to unsubscribe from.
⋮----
// ResourceUpdatedNotification is a notification from the server to the client,
// informing it that a resource has changed and may need to be read again. This
// should only be sent if the client previously sent a resources/subscribe request.
type ResourceUpdatedNotification struct {
	Notification
	Params struct {
		// The URI of the resource that has been updated. This might be a sub-
		// resource of the one that the client actually subscribed to.
		URI string `json:"uri"`
	} `json:"params"`
⋮----
// The URI of the resource that has been updated. This might be a sub-
// resource of the one that the client actually subscribed to.
⋮----
// Resource represents a known resource that the server is capable of reading.
type Resource struct {
	Annotated
	// The URI of this resource.
	URI string `json:"uri"`
	// A human-readable name for this resource.
	//
	// This can be used by clients to populate UI elements.
	Name string `json:"name"`
	// A description of what this resource represents.
	//
	// This can be used by clients to improve the LLM's understanding of
	// available resources. It can be thought of like a "hint" to the model.
	Description string `json:"description,omitempty"`
	// The MIME type of this resource, if known.
	MIMEType string `json:"mimeType,omitempty"`
}
⋮----
// The URI of this resource.
⋮----
// A human-readable name for this resource.
⋮----
// This can be used by clients to populate UI elements.
⋮----
// A description of what this resource represents.
⋮----
// available resources. It can be thought of like a "hint" to the model.
⋮----
// The MIME type of this resource, if known.
⋮----
// ResourceTemplate represents a template description for resources available
// on the server.
type ResourceTemplate struct {
	Annotated
	// A URI template (according to RFC 6570) that can be used to construct
	// resource URIs.
	URITemplate *URITemplate `json:"uriTemplate"`
	// A human-readable name for the type of resource this template refers to.
	//
	// This can be used by clients to populate UI elements.
	Name string `json:"name"`
	// A description of what this template is for.
	//
	// This can be used by clients to improve the LLM's understanding of
	// available resources. It can be thought of like a "hint" to the model.
	Description string `json:"description,omitempty"`
	// The MIME type for all resources that match this template. This should only
	// be included if all resources matching this template have the same type.
	MIMEType string `json:"mimeType,omitempty"`
}
⋮----
// A URI template (according to RFC 6570) that can be used to construct
// resource URIs.
⋮----
// A human-readable name for the type of resource this template refers to.
⋮----
// A description of what this template is for.
⋮----
// The MIME type for all resources that match this template. This should only
// be included if all resources matching this template have the same type.
⋮----
// ResourceContents represents the contents of a specific resource or sub-
// resource.
type ResourceContents interface {
	isResourceContents()
}
⋮----
type TextResourceContents struct {
	// The URI of this resource.
	URI string `json:"uri"`
	// The MIME type of this resource, if known.
	MIMEType string `json:"mimeType,omitempty"`
	// The text of the item. This must only be set if the item can actually be
	// represented as text (not binary data).
	Text string `json:"text"`
}
⋮----
// The text of the item. This must only be set if the item can actually be
// represented as text (not binary data).
⋮----
func (TextResourceContents) isResourceContents()
⋮----
type BlobResourceContents struct {
	// The URI of this resource.
	URI string `json:"uri"`
	// The MIME type of this resource, if known.
	MIMEType string `json:"mimeType,omitempty"`
	// A base64-encoded string representing the binary data of the item.
	Blob string `json:"blob"`
}
⋮----
// A base64-encoded string representing the binary data of the item.
⋮----
/* Logging */
⋮----
// SetLevelRequest is a request from the client to the server, to enable or
// adjust logging.
type SetLevelRequest struct {
	Request
	Params struct {
		// The level of logging that the client wants to receive from the server.
		// The server should send all logs at this level and higher (i.e., more severe) to
		// the client as notifications/logging/message.
		Level LoggingLevel `json:"level"`
	} `json:"params"`
⋮----
// The level of logging that the client wants to receive from the server.
// The server should send all logs at this level and higher (i.e., more severe) to
// the client as notifications/logging/message.
⋮----
// LoggingMessageNotification is a notification of a log message passed from
// server to client. If no logging/setLevel request has been sent from the client,
// the server MAY decide which messages to send automatically.
type LoggingMessageNotification struct {
	Notification
	Params struct {
		// The severity of this log message.
		Level LoggingLevel `json:"level"`
		// An optional name of the logger issuing this message.
		Logger string `json:"logger,omitempty"`
		// The data to be logged, such as a string message or an object. Any JSON
		// serializable type is allowed here.
		Data interface{} `json:"data"`
⋮----
// The severity of this log message.
⋮----
// An optional name of the logger issuing this message.
⋮----
// The data to be logged, such as a string message or an object. Any JSON
// serializable type is allowed here.
⋮----
// LoggingLevel represents the severity of a log message.
⋮----
// These map to syslog message severities, as specified in RFC-5424:
// https://datatracker.ietf.org/doc/html/rfc5424#section-6.2.1
type LoggingLevel string
⋮----
const (
	LoggingLevelDebug     LoggingLevel = "debug"
	LoggingLevelInfo      LoggingLevel = "info"
	LoggingLevelNotice    LoggingLevel = "notice"
	LoggingLevelWarning   LoggingLevel = "warning"
	LoggingLevelError     LoggingLevel = "error"
	LoggingLevelCritical  LoggingLevel = "critical"
	LoggingLevelAlert     LoggingLevel = "alert"
	LoggingLevelEmergency LoggingLevel = "emergency"
)
⋮----
/* Sampling */
⋮----
// CreateMessageRequest is a request from the server to sample an LLM via the
// client. The client has full discretion over which model to select. The client
// should also inform the user before beginning sampling, to allow them to inspect
// the request (human in the loop) and decide whether to approve it.
type CreateMessageRequest struct {
	Request
	Params struct {
		Messages         []SamplingMessage `json:"messages"`
		ModelPreferences *ModelPreferences `json:"modelPreferences,omitempty"`
		SystemPrompt     string            `json:"systemPrompt,omitempty"`
		IncludeContext   string            `json:"includeContext,omitempty"`
		Temperature      float64           `json:"temperature,omitempty"`
		MaxTokens        int               `json:"maxTokens"`
		StopSequences    []string          `json:"stopSequences,omitempty"`
		Metadata         interface{}       `json:"metadata,omitempty"`
⋮----
// CreateMessageResult is the client's response to a sampling/create_message
// request from the server. The client should inform the user before returning the
// sampled message, to allow them to inspect the response (human in the loop) and
// decide whether to allow the server to see it.
type CreateMessageResult struct {
	Result
	SamplingMessage
	// The name of the model that generated the message.
	Model string `json:"model"`
	// The reason why sampling stopped, if known.
	StopReason string `json:"stopReason,omitempty"`
}
⋮----
// The name of the model that generated the message.
⋮----
// The reason why sampling stopped, if known.
⋮----
// SamplingMessage describes a message issued to or received from an LLM API.
type SamplingMessage struct {
	Role    Role        `json:"role"`
	Content interface{} `json:"content"` // Can be TextContent or ImageContent
⋮----
Content interface{} `json:"content"` // Can be TextContent or ImageContent
⋮----
// Annotated is the base for objects that include optional annotations for the
// client. The client can use annotations to inform how objects are used or
// displayed
type Annotated struct {
	Annotations *struct {
		// Describes who the intended customer of this object or data is.
		//
		// It can include multiple entries to indicate content useful for multiple
		// audiences (e.g., `["user", "assistant"]`).
		Audience []Role `json:"audience,omitempty"`

		// Describes how important this data is for operating the server.
		//
		// A value of 1 means "most important," and indicates that the data is
		// effectively required, while 0 means "least important," and indicates that
		// the data is entirely optional.
		Priority float64 `json:"priority,omitempty"`
	} `json:"annotations,omitempty"`
⋮----
// Describes who the intended customer of this object or data is.
⋮----
// It can include multiple entries to indicate content useful for multiple
// audiences (e.g., `["user", "assistant"]`).
⋮----
// Describes how important this data is for operating the server.
⋮----
// A value of 1 means "most important," and indicates that the data is
// effectively required, while 0 means "least important," and indicates that
// the data is entirely optional.
⋮----
type Content interface {
	isContent()
}
⋮----
// TextContent represents text provided to or from an LLM.
// It must have Type set to "text".
type TextContent struct {
	Annotated
	Type string `json:"type"` // Must be "text"
	// The text content of the message.
	Text string `json:"text"`
}
⋮----
Type string `json:"type"` // Must be "text"
// The text content of the message.
⋮----
func (TextContent) isContent()
⋮----
// ImageContent represents an image provided to or from an LLM.
// It must have Type set to "image".
type ImageContent struct {
	Annotated
	Type string `json:"type"` // Must be "image"
	// The base64-encoded image data.
	Data string `json:"data"`
	// The MIME type of the image. Different providers may support different image types.
	MIMEType string `json:"mimeType"`
}
⋮----
Type string `json:"type"` // Must be "image"
// The base64-encoded image data.
⋮----
// The MIME type of the image. Different providers may support different image types.
⋮----
// EmbeddedResource represents the contents of a resource, embedded into a prompt or tool call result.
⋮----
// It is up to the client how best to render embedded resources for the
// benefit of the LLM and/or the user.
type EmbeddedResource struct {
	Annotated
	Type     string           `json:"type"`
	Resource ResourceContents `json:"resource"`
}
⋮----
// ModelPreferences represents the server's preferences for model selection,
// requested of the client during sampling.
⋮----
// Because LLMs can vary along multiple dimensions, choosing the "best" modelis
// rarely straightforward.  Different models excel in different areas—some are
// faster but less capable, others are more capable but more expensive, and so
// on. This interface allows servers to express their priorities across multiple
// dimensions to help clients make an appropriate selection for their use case.
⋮----
// These preferences are always advisory. The client MAY ignore them. It is also
// up to the client to decide how to interpret these preferences and how to
// balance them against other considerations.
type ModelPreferences struct {
	// Optional hints to use for model selection.
	//
	// If multiple hints are specified, the client MUST evaluate them in order
	// (such that the first match is taken).
	//
	// The client SHOULD prioritize these hints over the numeric priorities, but
	// MAY still use the priorities to select from ambiguous matches.
	Hints []ModelHint `json:"hints,omitempty"`

	// How much to prioritize cost when selecting a model. A value of 0 means cost
	// is not important, while a value of 1 means cost is the most important
	// factor.
	CostPriority float64 `json:"costPriority,omitempty"`

	// How much to prioritize sampling speed (latency) when selecting a model. A
	// value of 0 means speed is not important, while a value of 1 means speed is
	// the most important factor.
	SpeedPriority float64 `json:"speedPriority,omitempty"`

	// How much to prioritize intelligence and capabilities when selecting a
	// model. A value of 0 means intelligence is not important, while a value of 1
	// means intelligence is the most important factor.
	IntelligencePriority float64 `json:"intelligencePriority,omitempty"`
}
⋮----
// Optional hints to use for model selection.
⋮----
// If multiple hints are specified, the client MUST evaluate them in order
// (such that the first match is taken).
⋮----
// The client SHOULD prioritize these hints over the numeric priorities, but
// MAY still use the priorities to select from ambiguous matches.
⋮----
// How much to prioritize cost when selecting a model. A value of 0 means cost
// is not important, while a value of 1 means cost is the most important
// factor.
⋮----
// How much to prioritize sampling speed (latency) when selecting a model. A
// value of 0 means speed is not important, while a value of 1 means speed is
// the most important factor.
⋮----
// How much to prioritize intelligence and capabilities when selecting a
// model. A value of 0 means intelligence is not important, while a value of 1
// means intelligence is the most important factor.
⋮----
// ModelHint represents hints to use for model selection.
⋮----
// Keys not declared here are currently left unspecified by the spec and are up
// to the client to interpret.
type ModelHint struct {
	// A hint for a model name.
	//
	// The client SHOULD treat this as a substring of a model name; for example:
	//  - `claude-3-5-sonnet` should match `claude-3-5-sonnet-20241022`
	//  - `sonnet` should match `claude-3-5-sonnet-20241022`, `claude-3-sonnet-20240229`, etc.
	//  - `claude` should match any Claude model
	//
	// The client MAY also map the string to a different provider's model name or
	// a different model family, as long as it fills a similar niche; for example:
	//  - `gemini-1.5-flash` could match `claude-3-haiku-20240307`
	Name string `json:"name,omitempty"`
}
⋮----
// A hint for a model name.
⋮----
// The client SHOULD treat this as a substring of a model name; for example:
//  - `claude-3-5-sonnet` should match `claude-3-5-sonnet-20241022`
//  - `sonnet` should match `claude-3-5-sonnet-20241022`, `claude-3-sonnet-20240229`, etc.
//  - `claude` should match any Claude model
⋮----
// The client MAY also map the string to a different provider's model name or
// a different model family, as long as it fills a similar niche; for example:
//  - `gemini-1.5-flash` could match `claude-3-haiku-20240307`
⋮----
/* Autocomplete */
⋮----
// CompleteRequest is a request from the client to the server, to ask for completion options.
type CompleteRequest struct {
	Request
	Params struct {
		Ref      interface{} `json:"ref"` // Can be PromptReference or ResourceReference
⋮----
Ref      interface{} `json:"ref"` // Can be PromptReference or ResourceReference
⋮----
// The name of the argument
⋮----
// The value of the argument to use for completion matching.
⋮----
// CompleteResult is the server's response to a completion/complete request
type CompleteResult struct {
	Result
	Completion struct {
		// An array of completion values. Must not exceed 100 items.
		Values []string `json:"values"`
		// The total number of completion options available. This can exceed the
		// number of values actually sent in the response.
		Total int `json:"total,omitempty"`
		// Indicates whether there are additional completion options beyond those
		// provided in the current response, even if the exact total is unknown.
		HasMore bool `json:"hasMore,omitempty"`
	} `json:"completion"`
⋮----
// An array of completion values. Must not exceed 100 items.
⋮----
// The total number of completion options available. This can exceed the
// number of values actually sent in the response.
⋮----
// Indicates whether there are additional completion options beyond those
// provided in the current response, even if the exact total is unknown.
⋮----
// ResourceReference is a reference to a resource or resource template definition.
type ResourceReference struct {
	Type string `json:"type"`
	// The URI or URI template of the resource.
	URI string `json:"uri"`
}
⋮----
// The URI or URI template of the resource.
⋮----
// PromptReference identifies a prompt.
type PromptReference struct {
	Type string `json:"type"`
	// The name of the prompt or prompt template
	Name string `json:"name"`
}
⋮----
// The name of the prompt or prompt template
⋮----
/* Roots */
⋮----
// ListRootsRequest is sent from the server to request a list of root URIs from the client. Roots allow
// servers to ask for specific directories or files to operate on. A common example
// for roots is providing a set of repositories or directories a server should operate
// on.
⋮----
// This request is typically used when the server needs to understand the file system
// structure or access specific locations that the client has permission to read from.
type ListRootsRequest struct {
	Request
}
⋮----
// ListRootsResult is the client's response to a roots/list request from the server.
// This result contains an array of Root objects, each representing a root directory
// or file that the server can operate on.
type ListRootsResult struct {
	Result
	Roots []Root `json:"roots"`
}
⋮----
// Root represents a root directory or file that the server can operate on.
type Root struct {
	// The URI identifying the root. This *must* start with file:// for now.
	// This restriction may be relaxed in future versions of the protocol to allow
	// other URI schemes.
	URI string `json:"uri"`
	// An optional name for the root. This can be used to provide a human-readable
	// identifier for the root, which may be useful for display purposes or for
	// referencing the root in other parts of the application.
	Name string `json:"name,omitempty"`
}
⋮----
// The URI identifying the root. This *must* start with file:// for now.
// This restriction may be relaxed in future versions of the protocol to allow
// other URI schemes.
⋮----
// An optional name for the root. This can be used to provide a human-readable
// identifier for the root, which may be useful for display purposes or for
// referencing the root in other parts of the application.
⋮----
// RootsListChangedNotification is a notification from the client to the
// server, informing it that the list of roots has changed.
// This notification should be sent whenever the client adds, removes, or modifies any root.
// The server should then request an updated list of roots using the ListRootsRequest.
type RootsListChangedNotification struct {
	Notification
}
⋮----
/* Client messages */
// ClientRequest represents any request that can be sent from client to server.
type ClientRequest interface{}
⋮----
// ClientNotification represents any notification that can be sent from client to server.
type ClientNotification interface{}
⋮----
// ClientResult represents any result that can be sent from client to server.
type ClientResult interface{}
⋮----
/* Server messages */
// ServerRequest represents any request that can be sent from server to client.
type ServerRequest interface{}
⋮----
// ServerNotification represents any notification that can be sent from server to client.
type ServerNotification interface{}
⋮----
// ServerResult represents any result that can be sent from server to client.
type ServerResult interface{}
</file>

<file path="mcp/utils.go">
package mcp
⋮----
import (
	"encoding/json"
	"fmt"
)
⋮----
"encoding/json"
"fmt"
⋮----
// ClientRequest types
var _ ClientRequest = &PingRequest{}
var _ ClientRequest = &InitializeRequest{}
var _ ClientRequest = &CompleteRequest{}
var _ ClientRequest = &SetLevelRequest{}
var _ ClientRequest = &GetPromptRequest{}
var _ ClientRequest = &ListPromptsRequest{}
var _ ClientRequest = &ListResourcesRequest{}
var _ ClientRequest = &ReadResourceRequest{}
var _ ClientRequest = &SubscribeRequest{}
var _ ClientRequest = &UnsubscribeRequest{}
var _ ClientRequest = &CallToolRequest{}
var _ ClientRequest = &ListToolsRequest{}
⋮----
// ClientNotification types
var _ ClientNotification = &CancelledNotification{}
var _ ClientNotification = &ProgressNotification{}
var _ ClientNotification = &InitializedNotification{}
var _ ClientNotification = &RootsListChangedNotification{}
⋮----
// ClientResult types
var _ ClientResult = &EmptyResult{}
var _ ClientResult = &CreateMessageResult{}
var _ ClientResult = &ListRootsResult{}
⋮----
// ServerRequest types
var _ ServerRequest = &PingRequest{}
var _ ServerRequest = &CreateMessageRequest{}
var _ ServerRequest = &ListRootsRequest{}
⋮----
// ServerNotification types
var _ ServerNotification = &CancelledNotification{}
var _ ServerNotification = &ProgressNotification{}
var _ ServerNotification = &LoggingMessageNotification{}
var _ ServerNotification = &ResourceUpdatedNotification{}
var _ ServerNotification = &ResourceListChangedNotification{}
var _ ServerNotification = &ToolListChangedNotification{}
var _ ServerNotification = &PromptListChangedNotification{}
⋮----
// ServerResult types
var _ ServerResult = &EmptyResult{}
var _ ServerResult = &InitializeResult{}
var _ ServerResult = &CompleteResult{}
var _ ServerResult = &GetPromptResult{}
var _ ServerResult = &ListPromptsResult{}
var _ ServerResult = &ListResourcesResult{}
var _ ServerResult = &ReadResourceResult{}
var _ ServerResult = &CallToolResult{}
var _ ServerResult = &ListToolsResult{}
⋮----
// Helper functions for type assertions
⋮----
// asType attempts to cast the given interface to the given type
func asType[T any](content interface
⋮----
// AsTextContent attempts to cast the given interface to TextContent
func AsTextContent(content interface
⋮----
// AsImageContent attempts to cast the given interface to ImageContent
func AsImageContent(content interface
⋮----
// AsEmbeddedResource attempts to cast the given interface to EmbeddedResource
func AsEmbeddedResource(content interface
⋮----
// AsTextResourceContents attempts to cast the given interface to TextResourceContents
func AsTextResourceContents(content interface
⋮----
// AsBlobResourceContents attempts to cast the given interface to BlobResourceContents
func AsBlobResourceContents(content interface
⋮----
// Helper function for JSON-RPC
⋮----
// NewJSONRPCResponse creates a new JSONRPCResponse with the given id and result
func NewJSONRPCResponse(id RequestId, result Result) JSONRPCResponse
⋮----
// NewJSONRPCError creates a new JSONRPCResponse with the given id, code, and message
func NewJSONRPCError(
	id RequestId,
	code int,
	message string,
	data interface
⋮----
// Helper function for creating a progress notification
func NewProgressNotification(
	token ProgressToken,
	progress float64,
	total *float64,
) ProgressNotification
⋮----
// Helper function for creating a logging message notification
func NewLoggingMessageNotification(
	level LoggingLevel,
	logger string,
	data interface
⋮----
// Helper function to create a new PromptMessage
func NewPromptMessage(role Role, content Content) PromptMessage
⋮----
// Helper function to create a new TextContent
func NewTextContent(text string) TextContent
⋮----
// Helper function to create a new ImageContent
func NewImageContent(data, mimeType string) ImageContent
⋮----
// Helper function to create a new EmbeddedResource
func NewEmbeddedResource(resource ResourceContents) EmbeddedResource
⋮----
// NewToolResultText creates a new CallToolResult with a text content
func NewToolResultText(text string) *CallToolResult
⋮----
// NewToolResultImage creates a new CallToolResult with both text and image content
func NewToolResultImage(text, imageData, mimeType string) *CallToolResult
⋮----
// NewToolResultResource creates a new CallToolResult with an embedded resource
func NewToolResultResource(
	text string,
	resource ResourceContents,
) *CallToolResult
⋮----
// NewToolResultError creates a new CallToolResult with an error message.
// Any errors that originate from the tool SHOULD be reported inside the result object.
func NewToolResultError(text string) *CallToolResult
⋮----
// NewListResourcesResult creates a new ListResourcesResult
func NewListResourcesResult(
	resources []Resource,
	nextCursor Cursor,
) *ListResourcesResult
⋮----
// NewListResourceTemplatesResult creates a new ListResourceTemplatesResult
func NewListResourceTemplatesResult(
	templates []ResourceTemplate,
	nextCursor Cursor,
) *ListResourceTemplatesResult
⋮----
// NewReadResourceResult creates a new ReadResourceResult with text content
func NewReadResourceResult(text string) *ReadResourceResult
⋮----
// NewListPromptsResult creates a new ListPromptsResult
func NewListPromptsResult(
	prompts []Prompt,
	nextCursor Cursor,
) *ListPromptsResult
⋮----
// NewGetPromptResult creates a new GetPromptResult
func NewGetPromptResult(
	description string,
	messages []PromptMessage,
) *GetPromptResult
⋮----
// NewListToolsResult creates a new ListToolsResult
func NewListToolsResult(tools []Tool, nextCursor Cursor) *ListToolsResult
⋮----
// NewInitializeResult creates a new InitializeResult
func NewInitializeResult(
	protocolVersion string,
	capabilities ServerCapabilities,
	serverInfo Implementation,
	instructions string,
) *InitializeResult
⋮----
// Helper for formatting numbers in tool results
func FormatNumberResult(value float64) *CallToolResult
⋮----
func ExtractString(data map[string]any, key string) string
⋮----
func ExtractMap(data map[string]any, key string) map[string]any
⋮----
func ParseContent(contentMap map[string]any) (Content, error)
⋮----
func ParseGetPromptResult(rawMessage *json.RawMessage) (*GetPromptResult, error)
⋮----
var jsonContent map[string]any
⋮----
// Extract role
⋮----
// Extract content
⋮----
// Process content
⋮----
// Append processed message
⋮----
func ParseCallToolResult(rawMessage *json.RawMessage) (*CallToolResult, error)
⋮----
var result CallToolResult
⋮----
// Extract content
⋮----
// Process content
⋮----
func ParseResourceContents(contentMap map[string]any) (ResourceContents, error)
⋮----
func ParseReadResourceResult(rawMessage *json.RawMessage) (*ReadResourceResult, error)
⋮----
var result ReadResourceResult
</file>

<file path="server/internal/gen/data.go">
package main
⋮----
type MCPRequestType struct {
	MethodName     string
	ParamType      string
	ResultType     string
	HookName       string
	Group          string
	GroupName      string
	GroupHookName  string
	UnmarshalError string
	HandlerFunc    string
}
⋮----
var MCPRequestTypes = []MCPRequestType{
	{
		MethodName:     "MethodInitialize",
		ParamType:      "InitializeRequest",
		ResultType:     "InitializeResult",
		HookName:       "Initialize",
		UnmarshalError: "invalid initialize request",
		HandlerFunc:    "handleInitialize",
	}, {
		MethodName:     "MethodPing",
		ParamType:      "PingRequest",
		ResultType:     "EmptyResult",
		HookName:       "Ping",
		UnmarshalError: "invalid ping request",
		HandlerFunc:    "handlePing",
	}, {
		MethodName:     "MethodResourcesList",
		ParamType:      "ListResourcesRequest",
		ResultType:     "ListResourcesResult",
		Group:          "resources",
		GroupName:      "Resources",
		GroupHookName:  "Resource",
		HookName:       "ListResources",
		UnmarshalError: "invalid list resources request",
		HandlerFunc:    "handleListResources",
	}, {
		MethodName:     "MethodResourcesTemplatesList",
		ParamType:      "ListResourceTemplatesRequest",
		ResultType:     "ListResourceTemplatesResult",
		Group:          "resources",
		GroupName:      "Resources",
		GroupHookName:  "Resource",
		HookName:       "ListResourceTemplates",
		UnmarshalError: "invalid list resource templates request",
		HandlerFunc:    "handleListResourceTemplates",
	}, {
		MethodName:     "MethodResourcesRead",
		ParamType:      "ReadResourceRequest",
		ResultType:     "ReadResourceResult",
		Group:          "resources",
		GroupName:      "Resources",
		GroupHookName:  "Resource",
		HookName:       "ReadResource",
		UnmarshalError: "invalid read resource request",
		HandlerFunc:    "handleReadResource",
	}, {
		MethodName:     "MethodPromptsList",
		ParamType:      "ListPromptsRequest",
		ResultType:     "ListPromptsResult",
		Group:          "prompts",
		GroupName:      "Prompts",
		GroupHookName:  "Prompt",
		HookName:       "ListPrompts",
		UnmarshalError: "invalid list prompts request",
		HandlerFunc:    "handleListPrompts",
	}, {
		MethodName:     "MethodPromptsGet",
		ParamType:      "GetPromptRequest",
		ResultType:     "GetPromptResult",
		Group:          "prompts",
		GroupName:      "Prompts",
		GroupHookName:  "Prompt",
		HookName:       "GetPrompt",
		UnmarshalError: "invalid get prompt request",
		HandlerFunc:    "handleGetPrompt",
	}, {
		MethodName:     "MethodToolsList",
		ParamType:      "ListToolsRequest",
		ResultType:     "ListToolsResult",
		Group:          "tools",
		GroupName:      "Tools",
		GroupHookName:  "Tool",
		HookName:       "ListTools",
		UnmarshalError: "invalid list tools request",
		HandlerFunc:    "handleListTools",
	}, {
		MethodName:     "MethodToolsCall",
		ParamType:      "CallToolRequest",
		ResultType:     "CallToolResult",
		Group:          "tools",
		GroupName:      "Tools",
		GroupHookName:  "Tool",
		HookName:       "CallTool",
		UnmarshalError: "invalid call tool request",
		HandlerFunc:    "handleToolCall",
	},
}
</file>

<file path="server/internal/gen/hooks.go.tmpl">
// Code generated by `go generate`. DO NOT EDIT.
// source: server/internal/gen/hooks.go.tmpl
package server

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/mark3labs/mcp-go/mcp"
)

// OnRegisterSessionHookFunc is a hook that will be called when a new session is registered.
type OnRegisterSessionHookFunc func(ctx context.Context, session ClientSession)


// BeforeAnyHookFunc is a function that is called after the request is
// parsed but before the method is called.
type BeforeAnyHookFunc func(ctx context.Context, id any, method mcp.MCPMethod, message any)

// OnSuccessHookFunc is a hook that will be called after the request
// successfully generates a result, but before the result is sent to the client.
type OnSuccessHookFunc func(ctx context.Context, id any, method mcp.MCPMethod, message any, result any)

// OnErrorHookFunc is a hook that will be called when an error occurs,
// either during the request parsing or the method execution.
// 
// Example usage:
// ```
// hooks.AddOnError(func(ctx context.Context, id any, method mcp.MCPMethod, message any, err error) {
//   // Check for specific error types using errors.Is
//   if errors.Is(err, ErrUnsupported) {
//     // Handle capability not supported errors
//     log.Printf("Capability not supported: %v", err)
//   }
//
//   // Use errors.As to get specific error types
//   var parseErr = &UnparseableMessageError{}
//   if errors.As(err, &parseErr) {
//     // Access specific methods/fields of the error type
//     log.Printf("Failed to parse message for method %s: %v", 
//                parseErr.GetMethod(), parseErr.Unwrap())
//     // Access the raw message that failed to parse
//     rawMsg := parseErr.GetMessage()
//   }
//
//   // Check for specific resource/prompt/tool errors
//   switch {
//   case errors.Is(err, ErrResourceNotFound):
//     log.Printf("Resource not found: %v", err)
//   case errors.Is(err, ErrPromptNotFound):
//     log.Printf("Prompt not found: %v", err)
//   case errors.Is(err, ErrToolNotFound):
//     log.Printf("Tool not found: %v", err)
//   }
// })
type OnErrorHookFunc func(ctx context.Context, id any, method mcp.MCPMethod, message any, err error)

{{range .}}
type OnBefore{{.HookName}}Func func(ctx context.Context, id any, message *mcp.{{.ParamType}})
type OnAfter{{.HookName}}Func func(ctx context.Context, id any, message *mcp.{{.ParamType}}, result *mcp.{{.ResultType}})
{{end}}

type Hooks struct {
    OnRegisterSession []OnRegisterSessionHookFunc
	OnBeforeAny      []BeforeAnyHookFunc
	OnSuccess        []OnSuccessHookFunc
	OnError          []OnErrorHookFunc
{{- range .}}
	OnBefore{{.HookName}} []OnBefore{{.HookName}}Func
	OnAfter{{.HookName}}  []OnAfter{{.HookName}}Func
{{- end}}
}

func (c *Hooks) AddBeforeAny(hook BeforeAnyHookFunc) {
	c.OnBeforeAny = append(c.OnBeforeAny, hook)
}

func (c *Hooks) AddOnSuccess(hook OnSuccessHookFunc) {
	c.OnSuccess = append(c.OnSuccess, hook)
}

// AddOnError registers a hook function that will be called when an error occurs.
// The error parameter contains the actual error object, which can be interrogated
// using Go's error handling patterns like errors.Is and errors.As.
//
// Example:
// ```
// // Create a channel to receive errors for testing
// errChan := make(chan error, 1)
// 
// // Register hook to capture and inspect errors
// hooks := &Hooks{}
// hooks.AddOnError(func(ctx context.Context, id any, method mcp.MCPMethod, message any, err error) {
//     // For capability-related errors
//     if errors.Is(err, ErrUnsupported) {
//         // Handle capability not supported
//         errChan <- err
//         return
//     }
//
//     // For parsing errors
//     var parseErr = &UnparseableMessageError{}
//     if errors.As(err, &parseErr) {
//         // Handle unparseable message errors
//         fmt.Printf("Failed to parse %s request: %v\n", 
//                    parseErr.GetMethod(), parseErr.Unwrap())
//         errChan <- parseErr
//         return
//     }
//
//     // For resource/prompt/tool not found errors
//     if errors.Is(err, ErrResourceNotFound) ||
//        errors.Is(err, ErrPromptNotFound) ||
//        errors.Is(err, ErrToolNotFound) {
//         // Handle not found errors
//         errChan <- err
//         return
//     }
//
//     // For other errors
//     errChan <- err
// })
//
// server := NewMCPServer("test-server", "1.0.0", WithHooks(hooks))
// ```
func (c *Hooks) AddOnError(hook OnErrorHookFunc) {
	c.OnError = append(c.OnError, hook)
}

func (c *Hooks) beforeAny(ctx context.Context, id any, method mcp.MCPMethod, message any) {
	if c == nil {
		return
	}
	for _, hook := range c.OnBeforeAny {
		hook(ctx, id, method, message)
	}
}

func (c *Hooks) onSuccess(ctx context.Context, id any, method mcp.MCPMethod, message any, result any) {
	if c == nil {
		return
	}
	for _, hook := range c.OnSuccess {
		hook(ctx, id, method, message, result)
	}
}

// onError calls all registered error hooks with the error object.
// The err parameter contains the actual error that occurred, which implements
// the standard error interface and may be a wrapped error or custom error type.
//
// This allows consumer code to use Go's error handling patterns:
// - errors.Is(err, ErrUnsupported) to check for specific sentinel errors
// - errors.As(err, &customErr) to extract custom error types
//
// Common error types include:
// - ErrUnsupported: When a capability is not enabled
// - UnparseableMessageError: When request parsing fails
// - ErrResourceNotFound: When a resource is not found
// - ErrPromptNotFound: When a prompt is not found
// - ErrToolNotFound: When a tool is not found
func (c *Hooks) onError(ctx context.Context, id any, method mcp.MCPMethod, message any, err error) {
	if c == nil {
		return
	}
	for _, hook := range c.OnError {
		hook(ctx, id, method, message, err)
	}
}

func (c *Hooks) AddOnRegisterSession(hook OnRegisterSessionHookFunc) {
    c.OnRegisterSession = append(c.OnRegisterSession, hook)
}

func (c *Hooks) RegisterSession(ctx context.Context, session ClientSession) {
    if c == nil {
        return
    }
    for _, hook := range c.OnRegisterSession {
        hook(ctx, session)
    }
}

{{- range .}}
func (c *Hooks) AddBefore{{.HookName}}(hook OnBefore{{.HookName}}Func) {
	c.OnBefore{{.HookName}} = append(c.OnBefore{{.HookName}}, hook)
}

func (c *Hooks) AddAfter{{.HookName}}(hook OnAfter{{.HookName}}Func) {
	c.OnAfter{{.HookName}} = append(c.OnAfter{{.HookName}}, hook)
}

func (c *Hooks) before{{.HookName}}(ctx context.Context, id any, message *mcp.{{.ParamType}}) {
	c.beforeAny(ctx, id, mcp.{{.MethodName}}, message)
	if c == nil {
		return
	}
	for _, hook := range c.OnBefore{{.HookName}} {
		hook(ctx, id, message)
	}
}

func (c *Hooks) after{{.HookName}}(ctx context.Context, id any, message *mcp.{{.ParamType}}, result *mcp.{{.ResultType}}) {
	c.onSuccess(ctx, id, mcp.{{.MethodName}}, message, result)
	if c == nil {
		return
	}
	for _, hook := range c.OnAfter{{.HookName}} {
		hook(ctx, id, message, result)
	}
}
{{- end -}}
</file>

<file path="server/internal/gen/main.go">
package main
⋮----
import (
	_ "embed"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)
⋮----
_ "embed"
"fmt"
"io"
"log"
"os"
"os/exec"
"path/filepath"
"strings"
"text/template"
⋮----
//go:generate go run . ../..
⋮----
//go:embed hooks.go.tmpl
var hooksTemplate string
⋮----
//go:embed request_handler.go.tmpl
var requestHandlerTemplate string
⋮----
func RenderTemplateToFile(templateContent, destPath, fileName string, data any) error
⋮----
// Create temp file for initial output
⋮----
defer os.Remove(tempFilePath) // Clean up temp file when done
⋮----
// Parse and execute template to temp file
⋮----
// Run goimports on the temp file
⋮----
// Read the processed content
⋮----
// Write the processed content to the destination
var destWriter io.Writer
⋮----
func main()
</file>

<file path="server/internal/gen/README.md">
# Readme for Codegen

This internal module contains code generation for producing a few repetitive
constructs, namely:

- The switch statement that handles the request dispatch
- The hook function types and the methods on the Hook struct

To invoke the code generation:

```
go generate ./...
```

## Development

- `request_handler.go.tmpl` generates `server/request_handler.go`, and
- `hooks.go.tmpl` generates `server/hooks.go`

Inside of `data.go` there is a struct with the inputs to both templates.

Note that the driver in `main.go` generates code and also pipes it through
`goimports` for formatting and imports cleanup.
</file>

<file path="server/internal/gen/request_handler.go.tmpl">
// Code generated by `go generate`. DO NOT EDIT.
// source: server/internal/gen/request_handler.go.tmpl
package server

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/mark3labs/mcp-go/mcp"
)

// HandleMessage processes an incoming JSON-RPC message and returns an appropriate response
func (s *MCPServer) HandleMessage(
	ctx context.Context,
	message json.RawMessage,
) mcp.JSONRPCMessage {
	// Add server to context
	ctx = context.WithValue(ctx, serverKey{}, s)
	var err *requestError

	var baseMessage struct {
		JSONRPC string      `json:"jsonrpc"`
		Method  mcp.MCPMethod `json:"method"`
		ID      any           `json:"id,omitempty"`
	}

	if err := json.Unmarshal(message, &baseMessage); err != nil {
		return createErrorResponse(
			nil,
			mcp.PARSE_ERROR,
			"Failed to parse message",
		)
	}

	// Check for valid JSONRPC version
	if baseMessage.JSONRPC != mcp.JSONRPC_VERSION {
		return createErrorResponse(
			baseMessage.ID,
			mcp.INVALID_REQUEST,
			"Invalid JSON-RPC version",
		)
	}

	if baseMessage.ID == nil {
		var notification mcp.JSONRPCNotification
		if err := json.Unmarshal(message, &notification); err != nil {
			return createErrorResponse(
				nil,
				mcp.PARSE_ERROR,
				"Failed to parse notification",
			)
		}
		s.handleNotification(ctx, notification)
		return nil // Return nil for notifications
	}

	switch baseMessage.Method {
	{{- range .}}
	case mcp.{{.MethodName}}:
		var request mcp.{{.ParamType}}
		var result *mcp.{{.ResultType}}
		{{ if .Group }}if s.capabilities.{{.Group}} == nil {
			err = &requestError{
				id:   baseMessage.ID,
				code: mcp.METHOD_NOT_FOUND,
				err:  fmt.Errorf("{{toLower .GroupName}} %w", ErrUnsupported),
			}
		} else{{ end }} if unmarshalErr := json.Unmarshal(message, &request); unmarshalErr != nil {
			err = &requestError{
				id:   baseMessage.ID,
				code: mcp.INVALID_REQUEST,
				err:  &UnparseableMessageError{message: message, err: unmarshalErr, method: baseMessage.Method},
			}
		} else {
			s.hooks.before{{.HookName}}(ctx, baseMessage.ID, &request)
			result, err = s.{{.HandlerFunc}}(ctx, baseMessage.ID, request)
		}
		if err != nil {
			s.hooks.onError(ctx, baseMessage.ID, baseMessage.Method, &request, err)
			return err.ToJSONRPCError()
		}
		s.hooks.after{{.HookName}}(ctx, baseMessage.ID, &request, result)
		return createResponse(baseMessage.ID, *result)
	{{- end }}
	default:
		return createErrorResponse(
			baseMessage.ID,
			mcp.METHOD_NOT_FOUND,
			fmt.Sprintf("Method %s not found", baseMessage.Method),
		)
	}
}
</file>

<file path="server/hooks.go">
// Code generated by `go generate`. DO NOT EDIT.
// source: server/internal/gen/hooks.go.tmpl
package server
⋮----
import (
	"context"

	"github.com/mark3labs/mcp-go/mcp"
)
⋮----
"context"
⋮----
"github.com/mark3labs/mcp-go/mcp"
⋮----
// OnRegisterSessionHookFunc is a hook that will be called when a new session is registered.
type OnRegisterSessionHookFunc func(ctx context.Context, session ClientSession)
⋮----
// BeforeAnyHookFunc is a function that is called after the request is
// parsed but before the method is called.
type BeforeAnyHookFunc func(ctx context.Context, id any, method mcp.MCPMethod, message any)
⋮----
// OnSuccessHookFunc is a hook that will be called after the request
// successfully generates a result, but before the result is sent to the client.
type OnSuccessHookFunc func(ctx context.Context, id any, method mcp.MCPMethod, message any, result any)
⋮----
// OnErrorHookFunc is a hook that will be called when an error occurs,
// either during the request parsing or the method execution.
//
// Example usage:
// ```
⋮----
//	hooks.AddOnError(func(ctx context.Context, id any, method mcp.MCPMethod, message any, err error) {
//	  // Check for specific error types using errors.Is
//	  if errors.Is(err, ErrUnsupported) {
//	    // Handle capability not supported errors
//	    log.Printf("Capability not supported: %v", err)
//	  }
⋮----
//	  // Use errors.As to get specific error types
//	  var parseErr = &UnparseableMessageError{}
//	  if errors.As(err, &parseErr) {
//	    // Access specific methods/fields of the error type
//	    log.Printf("Failed to parse message for method %s: %v",
//	               parseErr.GetMethod(), parseErr.Unwrap())
//	    // Access the raw message that failed to parse
//	    rawMsg := parseErr.GetMessage()
⋮----
//	  // Check for specific resource/prompt/tool errors
//	  switch {
//	  case errors.Is(err, ErrResourceNotFound):
//	    log.Printf("Resource not found: %v", err)
//	  case errors.Is(err, ErrPromptNotFound):
//	    log.Printf("Prompt not found: %v", err)
//	  case errors.Is(err, ErrToolNotFound):
//	    log.Printf("Tool not found: %v", err)
⋮----
//	})
type OnErrorHookFunc func(ctx context.Context, id any, method mcp.MCPMethod, message any, err error)
⋮----
type OnBeforeInitializeFunc func(ctx context.Context, id any, message *mcp.InitializeRequest)
type OnAfterInitializeFunc func(ctx context.Context, id any, message *mcp.InitializeRequest, result *mcp.InitializeResult)
⋮----
type OnBeforePingFunc func(ctx context.Context, id any, message *mcp.PingRequest)
type OnAfterPingFunc func(ctx context.Context, id any, message *mcp.PingRequest, result *mcp.EmptyResult)
⋮----
type OnBeforeListResourcesFunc func(ctx context.Context, id any, message *mcp.ListResourcesRequest)
type OnAfterListResourcesFunc func(ctx context.Context, id any, message *mcp.ListResourcesRequest, result *mcp.ListResourcesResult)
⋮----
type OnBeforeListResourceTemplatesFunc func(ctx context.Context, id any, message *mcp.ListResourceTemplatesRequest)
type OnAfterListResourceTemplatesFunc func(ctx context.Context, id any, message *mcp.ListResourceTemplatesRequest, result *mcp.ListResourceTemplatesResult)
⋮----
type OnBeforeReadResourceFunc func(ctx context.Context, id any, message *mcp.ReadResourceRequest)
type OnAfterReadResourceFunc func(ctx context.Context, id any, message *mcp.ReadResourceRequest, result *mcp.ReadResourceResult)
⋮----
type OnBeforeListPromptsFunc func(ctx context.Context, id any, message *mcp.ListPromptsRequest)
type OnAfterListPromptsFunc func(ctx context.Context, id any, message *mcp.ListPromptsRequest, result *mcp.ListPromptsResult)
⋮----
type OnBeforeGetPromptFunc func(ctx context.Context, id any, message *mcp.GetPromptRequest)
type OnAfterGetPromptFunc func(ctx context.Context, id any, message *mcp.GetPromptRequest, result *mcp.GetPromptResult)
⋮----
type OnBeforeListToolsFunc func(ctx context.Context, id any, message *mcp.ListToolsRequest)
type OnAfterListToolsFunc func(ctx context.Context, id any, message *mcp.ListToolsRequest, result *mcp.ListToolsResult)
⋮----
type OnBeforeCallToolFunc func(ctx context.Context, id any, message *mcp.CallToolRequest)
type OnAfterCallToolFunc func(ctx context.Context, id any, message *mcp.CallToolRequest, result *mcp.CallToolResult)
⋮----
type Hooks struct {
	OnRegisterSession             []OnRegisterSessionHookFunc
	OnBeforeAny                   []BeforeAnyHookFunc
	OnSuccess                     []OnSuccessHookFunc
	OnError                       []OnErrorHookFunc
	OnBeforeInitialize            []OnBeforeInitializeFunc
	OnAfterInitialize             []OnAfterInitializeFunc
	OnBeforePing                  []OnBeforePingFunc
	OnAfterPing                   []OnAfterPingFunc
	OnBeforeListResources         []OnBeforeListResourcesFunc
	OnAfterListResources          []OnAfterListResourcesFunc
	OnBeforeListResourceTemplates []OnBeforeListResourceTemplatesFunc
	OnAfterListResourceTemplates  []OnAfterListResourceTemplatesFunc
	OnBeforeReadResource          []OnBeforeReadResourceFunc
	OnAfterReadResource           []OnAfterReadResourceFunc
	OnBeforeListPrompts           []OnBeforeListPromptsFunc
	OnAfterListPrompts            []OnAfterListPromptsFunc
	OnBeforeGetPrompt             []OnBeforeGetPromptFunc
	OnAfterGetPrompt              []OnAfterGetPromptFunc
	OnBeforeListTools             []OnBeforeListToolsFunc
	OnAfterListTools              []OnAfterListToolsFunc
	OnBeforeCallTool              []OnBeforeCallToolFunc
	OnAfterCallTool               []OnAfterCallToolFunc
}
⋮----
func (c *Hooks) AddBeforeAny(hook BeforeAnyHookFunc)
⋮----
func (c *Hooks) AddOnSuccess(hook OnSuccessHookFunc)
⋮----
// AddOnError registers a hook function that will be called when an error occurs.
// The error parameter contains the actual error object, which can be interrogated
// using Go's error handling patterns like errors.Is and errors.As.
⋮----
// Example:
⋮----
// // Create a channel to receive errors for testing
// errChan := make(chan error, 1)
⋮----
// // Register hook to capture and inspect errors
// hooks := &Hooks{}
⋮----
//	    // For capability-related errors
//	    if errors.Is(err, ErrUnsupported) {
//	        // Handle capability not supported
//	        errChan <- err
//	        return
//	    }
⋮----
//	    // For parsing errors
//	    var parseErr = &UnparseableMessageError{}
//	    if errors.As(err, &parseErr) {
//	        // Handle unparseable message errors
//	        fmt.Printf("Failed to parse %s request: %v\n",
//	                   parseErr.GetMethod(), parseErr.Unwrap())
//	        errChan <- parseErr
⋮----
//	    // For resource/prompt/tool not found errors
//	    if errors.Is(err, ErrResourceNotFound) ||
//	       errors.Is(err, ErrPromptNotFound) ||
//	       errors.Is(err, ErrToolNotFound) {
//	        // Handle not found errors
⋮----
//	    // For other errors
//	    errChan <- err
⋮----
// server := NewMCPServer("test-server", "1.0.0", WithHooks(hooks))
⋮----
func (c *Hooks) AddOnError(hook OnErrorHookFunc)
⋮----
func (c *Hooks) beforeAny(ctx context.Context, id any, method mcp.MCPMethod, message any)
⋮----
func (c *Hooks) onSuccess(ctx context.Context, id any, method mcp.MCPMethod, message any, result any)
⋮----
// onError calls all registered error hooks with the error object.
// The err parameter contains the actual error that occurred, which implements
// the standard error interface and may be a wrapped error or custom error type.
⋮----
// This allows consumer code to use Go's error handling patterns:
// - errors.Is(err, ErrUnsupported) to check for specific sentinel errors
// - errors.As(err, &customErr) to extract custom error types
⋮----
// Common error types include:
// - ErrUnsupported: When a capability is not enabled
// - UnparseableMessageError: When request parsing fails
// - ErrResourceNotFound: When a resource is not found
// - ErrPromptNotFound: When a prompt is not found
// - ErrToolNotFound: When a tool is not found
func (c *Hooks) onError(ctx context.Context, id any, method mcp.MCPMethod, message any, err error)
⋮----
func (c *Hooks) AddOnRegisterSession(hook OnRegisterSessionHookFunc)
⋮----
func (c *Hooks) RegisterSession(ctx context.Context, session ClientSession)
func (c *Hooks) AddBeforeInitialize(hook OnBeforeInitializeFunc)
⋮----
func (c *Hooks) AddAfterInitialize(hook OnAfterInitializeFunc)
⋮----
func (c *Hooks) beforeInitialize(ctx context.Context, id any, message *mcp.InitializeRequest)
⋮----
func (c *Hooks) afterInitialize(ctx context.Context, id any, message *mcp.InitializeRequest, result *mcp.InitializeResult)
func (c *Hooks) AddBeforePing(hook OnBeforePingFunc)
⋮----
func (c *Hooks) AddAfterPing(hook OnAfterPingFunc)
⋮----
func (c *Hooks) beforePing(ctx context.Context, id any, message *mcp.PingRequest)
⋮----
func (c *Hooks) afterPing(ctx context.Context, id any, message *mcp.PingRequest, result *mcp.EmptyResult)
func (c *Hooks) AddBeforeListResources(hook OnBeforeListResourcesFunc)
⋮----
func (c *Hooks) AddAfterListResources(hook OnAfterListResourcesFunc)
⋮----
func (c *Hooks) beforeListResources(ctx context.Context, id any, message *mcp.ListResourcesRequest)
⋮----
func (c *Hooks) afterListResources(ctx context.Context, id any, message *mcp.ListResourcesRequest, result *mcp.ListResourcesResult)
func (c *Hooks) AddBeforeListResourceTemplates(hook OnBeforeListResourceTemplatesFunc)
⋮----
func (c *Hooks) AddAfterListResourceTemplates(hook OnAfterListResourceTemplatesFunc)
⋮----
func (c *Hooks) beforeListResourceTemplates(ctx context.Context, id any, message *mcp.ListResourceTemplatesRequest)
⋮----
func (c *Hooks) afterListResourceTemplates(ctx context.Context, id any, message *mcp.ListResourceTemplatesRequest, result *mcp.ListResourceTemplatesResult)
func (c *Hooks) AddBeforeReadResource(hook OnBeforeReadResourceFunc)
⋮----
func (c *Hooks) AddAfterReadResource(hook OnAfterReadResourceFunc)
⋮----
func (c *Hooks) beforeReadResource(ctx context.Context, id any, message *mcp.ReadResourceRequest)
⋮----
func (c *Hooks) afterReadResource(ctx context.Context, id any, message *mcp.ReadResourceRequest, result *mcp.ReadResourceResult)
func (c *Hooks) AddBeforeListPrompts(hook OnBeforeListPromptsFunc)
⋮----
func (c *Hooks) AddAfterListPrompts(hook OnAfterListPromptsFunc)
⋮----
func (c *Hooks) beforeListPrompts(ctx context.Context, id any, message *mcp.ListPromptsRequest)
⋮----
func (c *Hooks) afterListPrompts(ctx context.Context, id any, message *mcp.ListPromptsRequest, result *mcp.ListPromptsResult)
func (c *Hooks) AddBeforeGetPrompt(hook OnBeforeGetPromptFunc)
⋮----
func (c *Hooks) AddAfterGetPrompt(hook OnAfterGetPromptFunc)
⋮----
func (c *Hooks) beforeGetPrompt(ctx context.Context, id any, message *mcp.GetPromptRequest)
⋮----
func (c *Hooks) afterGetPrompt(ctx context.Context, id any, message *mcp.GetPromptRequest, result *mcp.GetPromptResult)
func (c *Hooks) AddBeforeListTools(hook OnBeforeListToolsFunc)
⋮----
func (c *Hooks) AddAfterListTools(hook OnAfterListToolsFunc)
⋮----
func (c *Hooks) beforeListTools(ctx context.Context, id any, message *mcp.ListToolsRequest)
⋮----
func (c *Hooks) afterListTools(ctx context.Context, id any, message *mcp.ListToolsRequest, result *mcp.ListToolsResult)
func (c *Hooks) AddBeforeCallTool(hook OnBeforeCallToolFunc)
⋮----
func (c *Hooks) AddAfterCallTool(hook OnAfterCallToolFunc)
⋮----
func (c *Hooks) beforeCallTool(ctx context.Context, id any, message *mcp.CallToolRequest)
⋮----
func (c *Hooks) afterCallTool(ctx context.Context, id any, message *mcp.CallToolRequest, result *mcp.CallToolResult)
</file>

<file path="server/request_handler.go">
// Code generated by `go generate`. DO NOT EDIT.
// source: server/internal/gen/request_handler.go.tmpl
package server
⋮----
import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/mark3labs/mcp-go/mcp"
)
⋮----
"context"
"encoding/json"
"fmt"
⋮----
"github.com/mark3labs/mcp-go/mcp"
⋮----
// HandleMessage processes an incoming JSON-RPC message and returns an appropriate response
func (s *MCPServer) HandleMessage(
	ctx context.Context,
	message json.RawMessage,
) mcp.JSONRPCMessage
⋮----
// Add server to context
⋮----
var err *requestError
⋮----
var baseMessage struct {
		JSONRPC string        `json:"jsonrpc"`
		Method  mcp.MCPMethod `json:"method"`
		ID      any           `json:"id,omitempty"`
	}
⋮----
// Check for valid JSONRPC version
⋮----
var notification mcp.JSONRPCNotification
⋮----
return nil // Return nil for notifications
⋮----
var request mcp.InitializeRequest
var result *mcp.InitializeResult
⋮----
var request mcp.PingRequest
var result *mcp.EmptyResult
⋮----
var request mcp.ListResourcesRequest
var result *mcp.ListResourcesResult
⋮----
var request mcp.ListResourceTemplatesRequest
var result *mcp.ListResourceTemplatesResult
⋮----
var request mcp.ReadResourceRequest
var result *mcp.ReadResourceResult
⋮----
var request mcp.ListPromptsRequest
var result *mcp.ListPromptsResult
⋮----
var request mcp.GetPromptRequest
var result *mcp.GetPromptResult
⋮----
var request mcp.ListToolsRequest
var result *mcp.ListToolsResult
⋮----
var request mcp.CallToolRequest
var result *mcp.CallToolResult
</file>

<file path="server/server_test.go">
package server
⋮----
import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"testing"
	"time"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)
⋮----
"context"
"encoding/base64"
"encoding/json"
"errors"
"fmt"
"testing"
"time"
⋮----
"github.com/mark3labs/mcp-go/mcp"
"github.com/stretchr/testify/assert"
"github.com/stretchr/testify/require"
⋮----
func TestMCPServer_NewMCPServer(t *testing.T)
⋮----
func TestMCPServer_Capabilities(t *testing.T)
⋮----
// Tools capability should be non-nil even when WithToolCapabilities(false) is used
⋮----
func TestMCPServer_Tools(t *testing.T)
⋮----
// also let's register inactive sessions
⋮----
// One for SetTools
⋮----
// One for DeleteTools
⋮----
// Expect a successful response with an empty list of tools
⋮----
func TestMCPServer_HandleValidMessages(t *testing.T)
⋮----
func TestMCPServer_HandlePagination(t *testing.T)
⋮----
func TestMCPServer_HandleNotifications(t *testing.T)
⋮----
func TestMCPServer_SendNotificationToClient(t *testing.T)
⋮----
func TestMCPServer_PromptHandling(t *testing.T)
⋮----
// Add a test prompt
⋮----
func TestMCPServer_HandleInvalidMessages(t *testing.T)
⋮----
var errs []error
⋮----
var unparseableErr = &UnparseableMessageError{}
var ok = errors.As(err, &unparseableErr)
⋮----
errs = nil // Reset errors for each test case
⋮----
func TestMCPServer_HandleUndefinedHandlers(t *testing.T)
⋮----
type beforeResult struct {
		method  mcp.MCPMethod
		message any
	}
type afterResult struct {
		method  mcp.MCPMethod
		message any
		result  any
	}
var beforeResults []beforeResult
var afterResults []afterResult
⋮----
// Add a test tool to enable tool capabilities
⋮----
func TestMCPServer_HandleMethodsWithoutCapabilities(t *testing.T)
⋮----
options:     []ServerOption{hooksOption}, // No capabilities at all
⋮----
func TestMCPServer_Instructions(t *testing.T)
⋮----
var server *MCPServer
⋮----
func TestMCPServer_ResourceTemplates(t *testing.T)
⋮----
// Validate that the template arguments are passed correctly to the handler
⋮----
// Need to serialize the json to map[string]string to validate the URITemplate is correctly marshalled
var resourceTemplate map[string]string
⋮----
// Validate that the resource values are returned correctly
⋮----
func createTestServer() *MCPServer
⋮----
type fakeSession struct {
	sessionID           string
	notificationChannel chan mcp.JSONRPCNotification
	initialized         bool
}
⋮----
func (f fakeSession) SessionID() string
⋮----
func (f fakeSession) NotificationChannel() chan<- mcp.JSONRPCNotification
⋮----
func (f fakeSession) Initialize()
⋮----
func (f fakeSession) Initialized() bool
⋮----
var _ ClientSession = fakeSession{}
⋮----
func TestMCPServer_WithHooks(t *testing.T)
⋮----
// Create hook counters to verify calls
var (
		beforeAnyCount   int
		onSuccessCount   int
		onErrorCount     int
		beforePingCount  int
		afterPingCount   int
		beforeToolsCount int
		afterToolsCount  int
	)
⋮----
// Collectors for message and result types
var beforeAnyMessages []any
var onSuccessData []struct {
		msg any
		res any
	}
var beforePingMessages []*mcp.PingRequest
var afterPingData []struct {
		msg *mcp.PingRequest
		res *mcp.EmptyResult
	}
⋮----
// Initialize hook handlers
⋮----
// Register "any" hooks with type verification
⋮----
// Only collect ping messages for our test
⋮----
// Only collect ping responses for our test
⋮----
// Register method-specific hooks with type verification
⋮----
// Create a server with the hooks
⋮----
// Add a test tool
⋮----
// Initialize the server
⋮----
// Test 1: Verify ping method hooks
⋮----
// Verify success response
⋮----
// Test 2: Verify tools/list method hooks
⋮----
// Test 3: Verify error hooks with invalid tool
⋮----
// Verify error response
⋮----
// Verify hook counts
⋮----
// Method-specific hooks should be called exactly once
⋮----
// General hooks should be called for all methods
// beforeAny is called for all 4 methods (initialize, ping, tools/list, tools/call)
⋮----
// onSuccess is called for all 3 success methods (initialize, ping, tools/list)
⋮----
// Error hook should be called once for the failed tools/call
⋮----
// Verify type matching between BeforeAny and BeforePing
⋮----
// Verify type matching between OnSuccess and AfterPing
</file>

<file path="server/server.go">
// Package server provides MCP (Model Control Protocol) server implementations.
package server
⋮----
import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"sort"
	"sync"

	"github.com/mark3labs/mcp-go/mcp"
)
⋮----
"context"
"encoding/base64"
"encoding/json"
"errors"
"fmt"
"reflect"
"sort"
"sync"
⋮----
"github.com/mark3labs/mcp-go/mcp"
⋮----
// resourceEntry holds both a resource and its handler
type resourceEntry struct {
	resource mcp.Resource
	handler  ResourceHandlerFunc
}
⋮----
// resourceTemplateEntry holds both a template and its handler
type resourceTemplateEntry struct {
	template mcp.ResourceTemplate
	handler  ResourceTemplateHandlerFunc
}
⋮----
// ServerOption is a function that configures an MCPServer.
type ServerOption func(*MCPServer)
⋮----
// ResourceHandlerFunc is a function that returns resource contents.
type ResourceHandlerFunc func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error)
⋮----
// ResourceTemplateHandlerFunc is a function that returns a resource template.
type ResourceTemplateHandlerFunc func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error)
⋮----
// PromptHandlerFunc handles prompt requests with given arguments.
type PromptHandlerFunc func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error)
⋮----
// ToolHandlerFunc handles tool calls with given arguments.
type ToolHandlerFunc func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error)
⋮----
// ServerTool combines a Tool with its ToolHandlerFunc.
type ServerTool struct {
	Tool    mcp.Tool
	Handler ToolHandlerFunc
}
⋮----
// ClientSession represents an active session that can be used by MCPServer to interact with client.
type ClientSession interface {
	// Initialize marks session as fully initialized and ready for notifications
	Initialize()
	// Initialized returns if session is ready to accept notifications
	Initialized() bool
	// NotificationChannel provides a channel suitable for sending notifications to client.
	NotificationChannel() chan<- mcp.JSONRPCNotification
	// SessionID is a unique identifier used to track user session.
	SessionID() string
}
⋮----
// Initialize marks session as fully initialized and ready for notifications
⋮----
// Initialized returns if session is ready to accept notifications
⋮----
// NotificationChannel provides a channel suitable for sending notifications to client.
⋮----
// SessionID is a unique identifier used to track user session.
⋮----
// clientSessionKey is the context key for storing current client notification channel.
type clientSessionKey struct{}
⋮----
// ClientSessionFromContext retrieves current client notification context from context.
func ClientSessionFromContext(ctx context.Context) ClientSession
⋮----
// UnparseableMessageError is attached to the RequestError when json.Unmarshal
// fails on the request.
type UnparseableMessageError struct {
	message json.RawMessage
	method  mcp.MCPMethod
	err     error
}
⋮----
func (e *UnparseableMessageError) Error() string
⋮----
func (e *UnparseableMessageError) Unwrap() error
⋮----
func (e *UnparseableMessageError) GetMessage() json.RawMessage
⋮----
func (e *UnparseableMessageError) GetMethod() mcp.MCPMethod
⋮----
// RequestError is an error that can be converted to a JSON-RPC error.
// Implements Unwrap() to allow inspecting the error chain.
type requestError struct {
	id   any
	code int
	err  error
}
⋮----
func (e *requestError) ToJSONRPCError() mcp.JSONRPCError
⋮----
var (
	ErrUnsupported      = errors.New("not supported")
⋮----
// NotificationHandlerFunc handles incoming notifications.
type NotificationHandlerFunc func(ctx context.Context, notification mcp.JSONRPCNotification)
⋮----
// MCPServer implements a Model Control Protocol server that can handle various types of requests
// including resources, prompts, and tools.
type MCPServer struct {
	mu                   sync.RWMutex // Add mutex for protecting shared resources
	name                 string
	version              string
	instructions         string
	resources            map[string]resourceEntry
	resourceTemplates    map[string]resourceTemplateEntry
	prompts              map[string]mcp.Prompt
	promptHandlers       map[string]PromptHandlerFunc
	tools                map[string]ServerTool
	notificationHandlers map[string]NotificationHandlerFunc
	capabilities         serverCapabilities
	paginationLimit      *int
	sessions             sync.Map
	hooks                *Hooks
}
⋮----
mu                   sync.RWMutex // Add mutex for protecting shared resources
⋮----
// serverKey is the context key for storing the server instance
type serverKey struct{}
⋮----
// ServerFromContext retrieves the MCPServer instance from a context
func ServerFromContext(ctx context.Context) *MCPServer
⋮----
// WithPaginationLimit sets the pagination limit for the server.
func WithPaginationLimit(limit int) ServerOption
⋮----
// WithContext sets the current client session and returns the provided context
func (s *MCPServer) WithContext(
	ctx context.Context,
	session ClientSession,
) context.Context
⋮----
// RegisterSession saves session that should be notified in case if some server attributes changed.
func (s *MCPServer) RegisterSession(
	ctx context.Context,
	session ClientSession,
) error
⋮----
// UnregisterSession removes from storage session that is shut down.
func (s *MCPServer) UnregisterSession(
	sessionID string,
)
⋮----
// sendNotificationToAllClients sends a notification to all the currently active clients.
func (s *MCPServer) sendNotificationToAllClients(
	method string,
	params map[string]any,
)
⋮----
// TODO: log blocked channel in the future versions
⋮----
// SendNotificationToClient sends a notification to the current client
func (s *MCPServer) SendNotificationToClient(
	ctx context.Context,
	method string,
	params map[string]any,
) error
⋮----
// serverCapabilities defines the supported features of the MCP server
type serverCapabilities struct {
	tools     *toolCapabilities
	resources *resourceCapabilities
	prompts   *promptCapabilities
	logging   bool
}
⋮----
// resourceCapabilities defines the supported resource-related features
type resourceCapabilities struct {
	subscribe   bool
	listChanged bool
}
⋮----
// promptCapabilities defines the supported prompt-related features
type promptCapabilities struct {
	listChanged bool
}
⋮----
// toolCapabilities defines the supported tool-related features
type toolCapabilities struct {
	listChanged bool
}
⋮----
// WithResourceCapabilities configures resource-related server capabilities
func WithResourceCapabilities(subscribe, listChanged bool) ServerOption
⋮----
// Always create a non-nil capability object
⋮----
// WithHooks allows adding hooks that will be called before or after
// either [all] requests or before / after specific request methods, or else
// prior to returning an error to the client.
func WithHooks(hooks *Hooks) ServerOption
⋮----
// WithPromptCapabilities configures prompt-related server capabilities
func WithPromptCapabilities(listChanged bool) ServerOption
⋮----
// WithToolCapabilities configures tool-related server capabilities
func WithToolCapabilities(listChanged bool) ServerOption
⋮----
// WithLogging enables logging capabilities for the server
func WithLogging() ServerOption
⋮----
// WithInstructions sets the server instructions for the client returned in the initialize response
func WithInstructions(instructions string) ServerOption
⋮----
// NewMCPServer creates a new MCP server instance with the given name, version and options
func NewMCPServer(
	name, version string,
	opts ...ServerOption,
) *MCPServer
⋮----
// AddResource registers a new resource and its handler
func (s *MCPServer) AddResource(
	resource mcp.Resource,
	handler ResourceHandlerFunc,
)
⋮----
// AddResourceTemplate registers a new resource template and its handler
func (s *MCPServer) AddResourceTemplate(
	template mcp.ResourceTemplate,
	handler ResourceTemplateHandlerFunc,
)
⋮----
// AddPrompt registers a new prompt handler with the given name
func (s *MCPServer) AddPrompt(prompt mcp.Prompt, handler PromptHandlerFunc)
⋮----
// AddTool registers a new tool and its handler
func (s *MCPServer) AddTool(tool mcp.Tool, handler ToolHandlerFunc)
⋮----
// AddTools registers multiple tools at once
func (s *MCPServer) AddTools(tools ...ServerTool)
⋮----
// Send notification to all initialized sessions
⋮----
// SetTools replaces all existing tools with the provided list
func (s *MCPServer) SetTools(tools ...ServerTool)
⋮----
// DeleteTools removes a tool from the server
func (s *MCPServer) DeleteTools(names ...string)
⋮----
// AddNotificationHandler registers a new handler for incoming notifications
func (s *MCPServer) AddNotificationHandler(
	method string,
	handler NotificationHandlerFunc,
)
⋮----
func (s *MCPServer) handleInitialize(
	ctx context.Context,
	id interface
⋮----
// Only add resource capabilities if they're configured
⋮----
// Only add prompt capabilities if they're configured
⋮----
// Only add tool capabilities if they're configured
⋮----
func (s *MCPServer) handlePing(
	ctx context.Context,
	id interface
⋮----
func listByPagination[T any](
	ctx context.Context,
	s *MCPServer,
	cursor mcp.Cursor,
	allElements []T,
) ([]T, mcp.Cursor, error)
⋮----
// set the next cursor
⋮----
func (s *MCPServer) handleListResources(
	ctx context.Context,
	id interface
⋮----
// Sort the resources by name
⋮----
func (s *MCPServer) handleListResourceTemplates(
	ctx context.Context,
	id interface
⋮----
func (s *MCPServer) handleReadResource(
	ctx context.Context,
	id interface
⋮----
// First try direct resource handlers
⋮----
// If no direct handler found, try matching against templates
var matchedHandler ResourceTemplateHandlerFunc
var matched bool
⋮----
// Convert matched variables to a map
⋮----
// matchesTemplate checks if a URI matches a URI template pattern
func matchesTemplate(uri string, template *mcp.URITemplate) bool
⋮----
func (s *MCPServer) handleListPrompts(
	ctx context.Context,
	id interface
⋮----
// sort prompts by name
⋮----
func (s *MCPServer) handleGetPrompt(
	ctx context.Context,
	id interface
⋮----
func (s *MCPServer) handleListTools(
	ctx context.Context,
	id interface
⋮----
// Get all tool names for consistent ordering
⋮----
// Sort the tool names for consistent ordering
⋮----
// Add tools in sorted order
⋮----
func (s *MCPServer) handleToolCall(
	ctx context.Context,
	id interface
⋮----
func (s *MCPServer) handleNotification(
	ctx context.Context,
	notification mcp.JSONRPCNotification,
) mcp.JSONRPCMessage
⋮----
func createResponse(id interface
⋮----
func createErrorResponse(
	id interface
</file>

<file path="server/sse_test.go">
package server
⋮----
import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"math/rand"
	"net/http"
	"net/http/httptest"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/mark3labs/mcp-go/mcp"
)
⋮----
"bytes"
"context"
"encoding/json"
"fmt"
"math/rand"
"net/http"
"net/http/httptest"
"strings"
"sync"
"testing"
"time"
⋮----
"github.com/mark3labs/mcp-go/mcp"
⋮----
func TestSSEServer(t *testing.T)
⋮----
// Connect to SSE endpoint
⋮----
// Read the endpoint event
⋮----
// Extract message endpoint URL
⋮----
// Send initialize request
⋮----
// Verify response
var response map[string]interface{}
⋮----
var wg sync.WaitGroup
⋮----
// Connect to SSE endpoint
⋮----
// Read the endpoint event
⋮----
// Send initialize request
⋮----
var response map[string]interface{}
⋮----
// Wait with timeout
⋮----
// All sessions completed successfully
⋮----
// Test 404 for unknown path first (simpler case)
⋮----
// Test SSE endpoint with proper cleanup
⋮----
// Read initial message in goroutine
⋮----
// Wait briefly for initial response then cancel
⋮----
// Wait briefly then cancel
⋮----
// The messageURL should already be correct since we set the baseURL correctly
// Test message endpoint
⋮----
// Clean up SSE connection
⋮----
// Use a custom context key to store a test value.
type testContextKey struct{}
⋮----
// Create a context function that sets a test value from the request.
// In real life this could be used to send configuration using headers
// or query parameters.
const testHeader = "X-Test-Header"
⋮----
// Add a tool which uses the context function.
⋮----
// Note this is agnostic to the transport type i.e. doesn't know about request headers.
⋮----
// Call the tool.
⋮----
// Set the test header to a custom value.
⋮----
var options []SSEOption
</file>

<file path="server/sse.go">
package server
⋮----
import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"net/url"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/google/uuid"
	"github.com/mark3labs/mcp-go/mcp"
)
⋮----
"context"
"encoding/json"
"fmt"
"net/http"
"net/http/httptest"
"net/url"
"strings"
"sync"
"sync/atomic"
"time"
⋮----
"github.com/google/uuid"
"github.com/mark3labs/mcp-go/mcp"
⋮----
// sseSession represents an active SSE connection.
type sseSession struct {
	writer              http.ResponseWriter
	flusher             http.Flusher
	done                chan struct{}
⋮----
eventQueue          chan string // Channel for queuing events
⋮----
// SSEContextFunc is a function that takes an existing context and the current
// request and returns a potentially modified context based on the request
// content. This can be used to inject context values from headers, for example.
type SSEContextFunc func(ctx context.Context, r *http.Request) context.Context
⋮----
func (s *sseSession) SessionID() string
⋮----
func (s *sseSession) NotificationChannel() chan<- mcp.JSONRPCNotification
⋮----
func (s *sseSession) Initialize()
⋮----
func (s *sseSession) Initialized() bool
⋮----
var _ ClientSession = (*sseSession)(nil)
⋮----
// SSEServer implements a Server-Sent Events (SSE) based MCP server.
// It provides real-time communication capabilities over HTTP using the SSE protocol.
type SSEServer struct {
	server          *MCPServer
	baseURL         string
	basePath        string
  useFullURLForMessageEndpoint bool
	messageEndpoint string
	sseEndpoint     string
	sessions        sync.Map
	srv             *http.Server
	contextFunc     SSEContextFunc

	keepAlive         bool
	keepAliveInterval time.Duration
}
⋮----
// SSEOption defines a function type for configuring SSEServer
type SSEOption func(*SSEServer)
⋮----
// WithBaseURL sets the base URL for the SSE server
func WithBaseURL(baseURL string) SSEOption
⋮----
// Check if the host is empty or only contains a port
⋮----
// Add a new option for setting base path
func WithBasePath(basePath string) SSEOption
⋮----
// Ensure the path starts with / and doesn't end with /
⋮----
// WithMessageEndpoint sets the message endpoint path
func WithMessageEndpoint(endpoint string) SSEOption
⋮----
// WithUseFullURLForMessageEndpoint controls whether the SSE server returns a complete URL (including baseURL)
// or just the path portion for the message endpoint. Set to false when clients will concatenate
// the baseURL themselves to avoid malformed URLs like "http://localhost/mcphttp://localhost/mcp/message".
func WithUseFullURLForMessageEndpoint(useFullURLForMessageEndpoint bool) SSEOption
⋮----
// WithSSEEndpoint sets the SSE endpoint path
func WithSSEEndpoint(endpoint string) SSEOption
⋮----
// WithHTTPServer sets the HTTP server instance
func WithHTTPServer(srv *http.Server) SSEOption
⋮----
func WithKeepAliveInterval(keepAliveInterval time.Duration) SSEOption
⋮----
func WithKeepAlive(keepAlive bool) SSEOption
⋮----
// WithContextFunc sets a function that will be called to customise the context
// to the server using the incoming request.
func WithSSEContextFunc(fn SSEContextFunc) SSEOption
⋮----
// NewSSEServer creates a new SSE server instance with the given MCP server and options.
func NewSSEServer(server *MCPServer, opts ...SSEOption) *SSEServer
⋮----
// Apply all options
⋮----
// NewTestServer creates a test server for testing purposes
func NewTestServer(server *MCPServer, opts ...SSEOption) *httptest.Server
⋮----
// Start begins serving SSE connections on the specified address.
// It sets up HTTP handlers for SSE and message endpoints.
func (s *SSEServer) Start(addr string) error
⋮----
// Shutdown gracefully stops the SSE server, closing all active sessions
// and shutting down the HTTP server.
func (s *SSEServer) Shutdown(ctx context.Context) error
⋮----
// handleSSE handles incoming SSE connection requests.
// It sets up appropriate headers and creates a new session for the client.
func (s *SSEServer) handleSSE(w http.ResponseWriter, r *http.Request)
⋮----
eventQueue:          make(chan string, 100), // Buffer for events
⋮----
// Start notification handler for this session
⋮----
// Event queued successfully
⋮----
// Start keep alive : ping
⋮----
//: ping - 2025-03-27 07:44:38.682659+00:00
⋮----
// Send the initial endpoint event
⋮----
// Main event loop - this runs in the HTTP handler goroutine
⋮----
// Write the event to the response
⋮----
// GetMessageEndpointForClient returns the appropriate message endpoint URL with session ID
// based on the useFullURLForMessageEndpoint configuration.
func (s *SSEServer) GetMessageEndpointForClient(sessionID string) string
⋮----
// handleMessage processes incoming JSON-RPC messages from clients and sends responses
// back through both the SSE connection and HTTP response.
func (s *SSEServer) handleMessage(w http.ResponseWriter, r *http.Request)
⋮----
// Set the client context before handling the message
⋮----
// Parse message as raw JSON
var rawMessage json.RawMessage
⋮----
// Process message through MCPServer
⋮----
// Only send response if there is one (not for notifications)
⋮----
// Queue the event for sending via SSE
⋮----
// Event queued successfully
⋮----
// Session is closed, don't try to queue
⋮----
// Queue is full, could log this
⋮----
// Send HTTP response
⋮----
// For notifications, just send 202 Accepted with no body
⋮----
// writeJSONRPCError writes a JSON-RPC error response with the given error details.
func (s *SSEServer) writeJSONRPCError(
	w http.ResponseWriter,
	id interface
⋮----
// SendEventToSession sends an event to a specific SSE session identified by sessionID.
// Returns an error if the session is not found or closed.
func (s *SSEServer) SendEventToSession(
	sessionID string,
	event interface
⋮----
// Queue the event for sending via SSE
⋮----
func (s *SSEServer) GetUrlPath(input string) (string, error)
⋮----
func (s *SSEServer) CompleteSseEndpoint() string
func (s *SSEServer) CompleteSsePath() string
⋮----
func (s *SSEServer) CompleteMessageEndpoint() string
func (s *SSEServer) CompleteMessagePath() string
⋮----
// ServeHTTP implements the http.Handler interface.
func (s *SSEServer) ServeHTTP(w http.ResponseWriter, r *http.Request)
⋮----
// Use exact path matching rather than Contains
</file>

<file path="server/stdio_test.go">
package server
⋮----
import (
	"bufio"
	"context"
	"encoding/json"
	"io"
	"log"
	"os"
	"testing"

	"github.com/mark3labs/mcp-go/mcp"
)
⋮----
"bufio"
"context"
"encoding/json"
"io"
"log"
"os"
"testing"
⋮----
"github.com/mark3labs/mcp-go/mcp"
⋮----
func TestStdioServer(t *testing.T)
⋮----
// Create pipes for stdin and stdout
⋮----
// Create server
⋮----
// Create context with cancel
⋮----
// Create error channel to catch server errors
⋮----
// Start server in goroutine
⋮----
// Create test message
⋮----
// Send request
⋮----
// Read response
⋮----
var response map[string]interface{}
⋮----
// Verify response structure
⋮----
// Clean up
⋮----
// Check for server errors
⋮----
// Use a custom context key to store a test value.
type testContextKey struct{}
⋮----
// Create a context function that sets a test value from the environment.
// In real life this could be used to send configuration in a similar way,
// or from a config file.
const testEnvVar = "TEST_ENV_VAR"
⋮----
// Add a tool which uses the context function.
⋮----
// Note this is agnostic to the transport type i.e. doesn't know about request headers.
⋮----
// Call the tool.
</file>

<file path="server/stdio.go">
package server
⋮----
import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"os/signal"
	"sync/atomic"
	"syscall"

	"github.com/mark3labs/mcp-go/mcp"
)
⋮----
"bufio"
"context"
"encoding/json"
"fmt"
"io"
"log"
"os"
"os/signal"
"sync/atomic"
"syscall"
⋮----
"github.com/mark3labs/mcp-go/mcp"
⋮----
// StdioContextFunc is a function that takes an existing context and returns
// a potentially modified context.
// This can be used to inject context values from environment variables,
// for example.
type StdioContextFunc func(ctx context.Context) context.Context
⋮----
// StdioServer wraps a MCPServer and handles stdio communication.
// It provides a simple way to create command-line MCP servers that
// communicate via standard input/output streams using JSON-RPC messages.
type StdioServer struct {
	server      *MCPServer
	errLogger   *log.Logger
	contextFunc StdioContextFunc
}
⋮----
// StdioOption defines a function type for configuring StdioServer
type StdioOption func(*StdioServer)
⋮----
// WithErrorLogger sets the error logger for the server
func WithErrorLogger(logger *log.Logger) StdioOption
⋮----
// WithContextFunc sets a function that will be called to customise the context
// to the server. Note that the stdio server uses the same context for all requests,
// so this function will only be called once per server instance.
func WithStdioContextFunc(fn StdioContextFunc) StdioOption
⋮----
// stdioSession is a static client session, since stdio has only one client.
type stdioSession struct {
	notifications chan mcp.JSONRPCNotification
	initialized   atomic.Bool
}
⋮----
func (s *stdioSession) SessionID() string
⋮----
func (s *stdioSession) NotificationChannel() chan<- mcp.JSONRPCNotification
⋮----
func (s *stdioSession) Initialize()
⋮----
func (s *stdioSession) Initialized() bool
⋮----
var _ ClientSession = (*stdioSession)(nil)
⋮----
var stdioSessionInstance = stdioSession{
	notifications: make(chan mcp.JSONRPCNotification, 100),
}
⋮----
// NewStdioServer creates a new stdio server wrapper around an MCPServer.
// It initializes the server with a default error logger that discards all output.
func NewStdioServer(server *MCPServer) *StdioServer
⋮----
), // Default to discarding logs
⋮----
// SetErrorLogger configures where error messages from the StdioServer are logged.
// The provided logger will receive all error messages generated during server operation.
func (s *StdioServer) SetErrorLogger(logger *log.Logger)
⋮----
// SetContextFunc sets a function that will be called to customise the context
⋮----
func (s *StdioServer) SetContextFunc(fn StdioContextFunc)
⋮----
// handleNotifications continuously processes notifications from the session's notification channel
// and writes them to the provided output. It runs until the context is cancelled.
// Any errors encountered while writing notifications are logged but do not stop the handler.
func (s *StdioServer) handleNotifications(ctx context.Context, stdout io.Writer)
⋮----
// processInputStream continuously reads and processes messages from the input stream.
// It handles EOF gracefully as a normal termination condition.
// The function returns when either:
// - The context is cancelled (returns context.Err())
// - EOF is encountered (returns nil)
// - An error occurs while reading or processing messages (returns the error)
func (s *StdioServer) processInputStream(ctx context.Context, reader *bufio.Reader, stdout io.Writer) error
⋮----
// readNextLine reads a single line from the input reader in a context-aware manner.
// It uses channels to make the read operation cancellable via context.
// Returns the read line and any error encountered. If the context is cancelled,
// returns an empty string and the context's error. EOF is returned when the input
// stream is closed.
func (s *StdioServer) readNextLine(ctx context.Context, reader *bufio.Reader) (string, error)
⋮----
// Listen starts listening for JSON-RPC messages on the provided input and writes responses to the provided output.
// It runs until the context is cancelled or an error occurs.
// Returns an error if there are issues with reading input or writing output.
func (s *StdioServer) Listen(
	ctx context.Context,
	stdin io.Reader,
	stdout io.Writer,
) error
⋮----
// Set a static client context since stdio only has one client
⋮----
// Add in any custom context.
⋮----
// Start notification handler
⋮----
// processMessage handles a single JSON-RPC message and writes the response.
// It parses the message, processes it through the wrapped MCPServer, and writes any response.
// Returns an error if there are issues with message processing or response writing.
func (s *StdioServer) processMessage(
	ctx context.Context,
	line string,
	writer io.Writer,
) error
⋮----
// Parse the message as raw JSON
var rawMessage json.RawMessage
⋮----
// Handle the message using the wrapped server
⋮----
// Only write response if there is one (not for notifications)
⋮----
// writeResponse marshals and writes a JSON-RPC response message followed by a newline.
// Returns an error if marshaling or writing fails.
func (s *StdioServer) writeResponse(
	response mcp.JSONRPCMessage,
	writer io.Writer,
) error
⋮----
// Write response followed by newline
⋮----
// ServeStdio is a convenience function that creates and starts a StdioServer with os.Stdin and os.Stdout.
// It sets up signal handling for graceful shutdown on SIGTERM and SIGINT.
// Returns an error if the server encounters any issues during operation.
func ServeStdio(server *MCPServer, opts ...StdioOption) error
⋮----
// Set up signal handling
</file>

<file path="testdata/mockstdio_server.go">
package main
⋮----
import (
	"bufio"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
)
⋮----
"bufio"
"encoding/json"
"fmt"
"log/slog"
"os"
⋮----
type JSONRPCRequest struct {
	JSONRPC string          `json:"jsonrpc"`
	ID      int64           `json:"id"`
	Method  string          `json:"method"`
	Params  json.RawMessage `json:"params"`
}
⋮----
type JSONRPCResponse struct {
	JSONRPC string      `json:"jsonrpc"`
	ID      int64       `json:"id"`
	Result  interface{} `json:"result,omitempty"`
⋮----
func main()
⋮----
var request JSONRPCRequest
⋮----
func handleRequest(request JSONRPCRequest) JSONRPCResponse
</file>

<file path=".gitignore">
.aider*
.env
.idea
</file>

<file path="go.mod">
module github.com/mark3labs/mcp-go

go 1.23

require (
	github.com/google/uuid v1.6.0
	github.com/stretchr/testify v1.9.0
	github.com/yosida95/uritemplate/v3 v3.0.2
)

require (
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Anthropic, PBC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.md">
<!-- omit in toc -->
# MCP Go 🚀
[![Build](https://github.com/mark3labs/mcp-go/actions/workflows/ci.yml/badge.svg?branch=main)](https://github.com/mark3labs/mcp-go/actions/workflows/ci.yml)
[![Go Report Card](https://goreportcard.com/badge/github.com/mark3labs/mcp-go?cache)](https://goreportcard.com/report/github.com/mark3labs/mcp-go)
[![GoDoc](https://pkg.go.dev/badge/github.com/mark3labs/mcp-go.svg)](https://pkg.go.dev/github.com/mark3labs/mcp-go)

<div align="center">

<strong>A Go implementation of the Model Context Protocol (MCP), enabling seamless integration between LLM applications and external data sources and tools.</strong>

<br>

[![Tutorial](http://img.youtube.com/vi/qoaeYMrXJH0/0.jpg)](http://www.youtube.com/watch?v=qoaeYMrXJH0 "Tutorial")

</div>

```go
package main

import (
    "context"
    "errors"
    "fmt"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

func main() {
    // Create MCP server
    s := server.NewMCPServer(
        "Demo 🚀",
        "1.0.0",
    )

    // Add tool
    tool := mcp.NewTool("hello_world",
        mcp.WithDescription("Say hello to someone"),
        mcp.WithString("name",
            mcp.Required(),
            mcp.Description("Name of the person to greet"),
        ),
    )

    // Add tool handler
    s.AddTool(tool, helloHandler)

    // Start the stdio server
    if err := server.ServeStdio(s); err != nil {
        fmt.Printf("Server error: %v\n", err)
    }
}

func helloHandler(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    name, ok := request.Params.Arguments["name"].(string)
    if !ok {
        return nil, errors.New("name must be a string")
    }

    return mcp.NewToolResultText(fmt.Sprintf("Hello, %s!", name)), nil
}
```

That's it!

MCP Go handles all the complex protocol details and server management, so you can focus on building great tools. It aims to be high-level and easy to use.

### Key features:
* **Fast**: High-level interface means less code and faster development
* **Simple**: Build MCP servers with minimal boilerplate
* **Complete***: MCP Go aims to provide a full implementation of the core MCP specification

(\*emphasis on *aims*)

🚨 🚧 🏗️ *MCP Go is under active development, as is the MCP specification itself. Core features are working but some advanced capabilities are still in progress.* 


<!-- omit in toc -->
## Table of Contents

- [Installation](#installation)
- [Quickstart](#quickstart)
- [What is MCP?](#what-is-mcp)
- [Core Concepts](#core-concepts)
  - [Server](#server)
  - [Resources](#resources)
  - [Tools](#tools)
  - [Prompts](#prompts)
- [Examples](#examples)
- [Contributing](#contributing)
  - [Prerequisites](#prerequisites)
  - [Installation](#installation-1)
  - [Testing](#testing)
  - [Opening a Pull Request](#opening-a-pull-request)

## Installation

```bash
go get github.com/mark3labs/mcp-go
```

## Quickstart

Let's create a simple MCP server that exposes a calculator tool and some data:

```go
package main

import (
    "context"
    "errors"
    "fmt"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

func main() {
    // Create a new MCP server
    s := server.NewMCPServer(
        "Calculator Demo",
        "1.0.0",
        server.WithResourceCapabilities(true, true),
        server.WithLogging(),
    )

    // Add a calculator tool
    calculatorTool := mcp.NewTool("calculate",
        mcp.WithDescription("Perform basic arithmetic operations"),
        mcp.WithString("operation",
            mcp.Required(),
            mcp.Description("The operation to perform (add, subtract, multiply, divide)"),
            mcp.Enum("add", "subtract", "multiply", "divide"),
        ),
        mcp.WithNumber("x",
            mcp.Required(),
            mcp.Description("First number"),
        ),
        mcp.WithNumber("y",
            mcp.Required(),
            mcp.Description("Second number"),
        ),
    )

    // Add the calculator handler
    s.AddTool(calculatorTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        op := request.Params.Arguments["operation"].(string)
        x := request.Params.Arguments["x"].(float64)
        y := request.Params.Arguments["y"].(float64)

        var result float64
        switch op {
        case "add":
            result = x + y
        case "subtract":
            result = x - y
        case "multiply":
            result = x * y
        case "divide":
            if y == 0 {
                return nil, errors.New("Cannot divide by zero")
            }
            result = x / y
        }

        return mcp.NewToolResultText(fmt.Sprintf("%.2f", result)), nil
    })

    // Start the server
    if err := server.ServeStdio(s); err != nil {
        fmt.Printf("Server error: %v\n", err)
    }
}
```
## What is MCP?

The [Model Context Protocol (MCP)](https://modelcontextprotocol.io) lets you build servers that expose data and functionality to LLM applications in a secure, standardized way. Think of it like a web API, but specifically designed for LLM interactions. MCP servers can:

- Expose data through **Resources** (think of these sort of like GET endpoints; they are used to load information into the LLM's context)
- Provide functionality through **Tools** (sort of like POST endpoints; they are used to execute code or otherwise produce a side effect)
- Define interaction patterns through **Prompts** (reusable templates for LLM interactions)
- And more!


## Core Concepts


### Server

<details>
<summary>Show Server Examples</summary>

The server is your core interface to the MCP protocol. It handles connection management, protocol compliance, and message routing:

```go
// Create a basic server
s := server.NewMCPServer(
    "My Server",  // Server name
    "1.0.0",     // Version
)

// Start the server using stdio
if err := server.ServeStdio(s); err != nil {
    log.Fatalf("Server error: %v", err)
}
```

</details>

### Resources

<details>
<summary>Show Resource Examples</summary>
Resources are how you expose data to LLMs. They can be anything - files, API responses, database queries, system information, etc. Resources can be:

- Static (fixed URI)
- Dynamic (using URI templates)

Here's a simple example of a static resource:

```go
// Static resource example - exposing a README file
resource := mcp.NewResource(
    "docs://readme",
    "Project README",
    mcp.WithResourceDescription("The project's README file"), 
    mcp.WithMIMEType("text/markdown"),
)

// Add resource with its handler
s.AddResource(resource, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    content, err := os.ReadFile("README.md")
    if err != nil {
        return nil, err
    }
    
    return []mcp.ResourceContents{
        mcp.TextResourceContents{
            URI:      "docs://readme",
            MIMEType: "text/markdown",
            Text:     string(content),
        },
    }, nil
})
```

And here's an example of a dynamic resource using a template:

```go
// Dynamic resource example - user profiles by ID
template := mcp.NewResourceTemplate(
    "users://{id}/profile",
    "User Profile",
    mcp.WithTemplateDescription("Returns user profile information"),
    mcp.WithTemplateMIMEType("application/json"),
)

// Add template with its handler
s.AddResourceTemplate(template, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    // Extract ID from the URI using regex matching
    // The server automatically matches URIs to templates
    userID := extractIDFromURI(request.Params.URI)
    
    profile, err := getUserProfile(userID)  // Your DB/API call here
    if err != nil {
        return nil, err
    }
    
    return []mcp.ResourceContents{
        mcp.TextResourceContents{
            URI:      request.Params.URI,
            MIMEType: "application/json",
            Text:     profile,
        },
    }, nil
})
```

The examples are simple but demonstrate the core concepts. Resources can be much more sophisticated - serving multiple contents, integrating with databases or external APIs, etc.
</details>

### Tools

<details>
<summary>Show Tool Examples</summary>

Tools let LLMs take actions through your server. Unlike resources, tools are expected to perform computation and have side effects. They're similar to POST endpoints in a REST API.

Simple calculation example:
```go
calculatorTool := mcp.NewTool("calculate",
    mcp.WithDescription("Perform basic arithmetic calculations"),
    mcp.WithString("operation",
        mcp.Required(),
        mcp.Description("The arithmetic operation to perform"),
        mcp.Enum("add", "subtract", "multiply", "divide"),
    ),
    mcp.WithNumber("x",
        mcp.Required(),
        mcp.Description("First number"),
    ),
    mcp.WithNumber("y",
        mcp.Required(),
        mcp.Description("Second number"),
    ),
)

s.AddTool(calculatorTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    op := request.Params.Arguments["operation"].(string)
    x := request.Params.Arguments["x"].(float64)
    y := request.Params.Arguments["y"].(float64)

    var result float64
    switch op {
    case "add":
        result = x + y
    case "subtract":
        result = x - y
    case "multiply":
        result = x * y
    case "divide":
        if y == 0 {
            return nil, errors.New("Division by zero is not allowed")
        }
        result = x / y
    }
    
    return mcp.FormatNumberResult(result), nil
})
```

HTTP request example:
```go
httpTool := mcp.NewTool("http_request",
    mcp.WithDescription("Make HTTP requests to external APIs"),
    mcp.WithString("method",
        mcp.Required(),
        mcp.Description("HTTP method to use"),
        mcp.Enum("GET", "POST", "PUT", "DELETE"),
    ),
    mcp.WithString("url",
        mcp.Required(),
        mcp.Description("URL to send the request to"),
        mcp.Pattern("^https?://.*"),
    ),
    mcp.WithString("body",
        mcp.Description("Request body (for POST/PUT)"),
    ),
)

s.AddTool(httpTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    method := request.Params.Arguments["method"].(string)
    url := request.Params.Arguments["url"].(string)
    body := ""
    if b, ok := request.Params.Arguments["body"].(string); ok {
        body = b
    }

    // Create and send request
    var req *http.Request
    var err error
    if body != "" {
        req, err = http.NewRequest(method, url, strings.NewReader(body))
    } else {
        req, err = http.NewRequest(method, url, nil)
    }
    if err != nil {
        return nil, fmt.Errorf("Failed to create request: %v", err)
    }

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("Request failed: %v", err)
    }
    defer resp.Body.Close()

    // Return response
    respBody, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("Failed to read response: %v", err)
    }

    return mcp.NewToolResultText(fmt.Sprintf("Status: %d\nBody: %s", resp.StatusCode, string(respBody))), nil
})
```

Tools can be used for any kind of computation or side effect:
- Database queries
- File operations  
- External API calls
- Calculations
- System operations

Each tool should:
- Have a clear description
- Validate inputs
- Handle errors gracefully 
- Return structured responses
- Use appropriate result types

</details>

### Prompts

<details>
<summary>Show Prompt Examples</summary>

Prompts are reusable templates that help LLMs interact with your server effectively. They're like "best practices" encoded into your server. Here are some examples:

```go
// Simple greeting prompt
s.AddPrompt(mcp.NewPrompt("greeting",
    mcp.WithPromptDescription("A friendly greeting prompt"),
    mcp.WithArgument("name",
        mcp.ArgumentDescription("Name of the person to greet"),
    ),
), func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    name := request.Params.Arguments["name"]
    if name == "" {
        name = "friend"
    }
    
    return mcp.NewGetPromptResult(
        "A friendly greeting",
        []mcp.PromptMessage{
            mcp.NewPromptMessage(
                mcp.RoleAssistant,
                mcp.NewTextContent(fmt.Sprintf("Hello, %s! How can I help you today?", name)),
            ),
        },
    ), nil
})

// Code review prompt with embedded resource
s.AddPrompt(mcp.NewPrompt("code_review",
    mcp.WithPromptDescription("Code review assistance"),
    mcp.WithArgument("pr_number",
        mcp.ArgumentDescription("Pull request number to review"),
        mcp.RequiredArgument(),
    ),
), func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    prNumber := request.Params.Arguments["pr_number"]
    if prNumber == "" {
        return nil, fmt.Errorf("pr_number is required")
    }
    
    return mcp.NewGetPromptResult(
        "Code review assistance",
        []mcp.PromptMessage{
            mcp.NewPromptMessage(
                mcp.RoleSystem,
                mcp.NewTextContent("You are a helpful code reviewer. Review the changes and provide constructive feedback."),
            ),
            mcp.NewPromptMessage(
                mcp.RoleAssistant,
                mcp.NewEmbeddedResource(mcp.ResourceContents{
                    URI: fmt.Sprintf("git://pulls/%s/diff", prNumber),
                    MIMEType: "text/x-diff",
                }),
            ),
        },
    ), nil
})

// Database query builder prompt
s.AddPrompt(mcp.NewPrompt("query_builder",
    mcp.WithPromptDescription("SQL query builder assistance"),
    mcp.WithArgument("table",
        mcp.ArgumentDescription("Name of the table to query"),
        mcp.RequiredArgument(),
    ),
), func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    tableName := request.Params.Arguments["table"]
    if tableName == "" {
        return nil, fmt.Errorf("table name is required")
    }
    
    return mcp.NewGetPromptResult(
        "SQL query builder assistance",
        []mcp.PromptMessage{
            mcp.NewPromptMessage(
                mcp.RoleSystem,
                mcp.NewTextContent("You are a SQL expert. Help construct efficient and safe queries."),
            ),
            mcp.NewPromptMessage(
                mcp.RoleAssistant,
                mcp.NewEmbeddedResource(mcp.ResourceContents{
                    URI: fmt.Sprintf("db://schema/%s", tableName),
                    MIMEType: "application/json",
                }),
            ),
        },
    ), nil
})
```

Prompts can include:
- System instructions
- Required arguments
- Embedded resources
- Multiple messages
- Different content types (text, images, etc.)
- Custom URI schemes

</details>

## Examples

For examples, see the `examples/` directory.

## Extras

### Request Hooks

Hook into the request lifecycle by creating a `Hooks` object with your
selection among the possible callbacks.  This enables telemetry across all
functionality, and observability of various facts, for example the ability
to count improperly-formatted requests, or to log the agent identity during
initialization.

Add the `Hooks` to the server at the time of creation using the
`server.WithHooks` option.

## Contributing

<details>

<summary><h3>Open Developer Guide</h3></summary>

### Prerequisites

Go version >= 1.23

### Installation

Create a fork of this repository, then clone it:

```bash
git clone https://github.com/mark3labs/mcp-go.git
cd mcp-go
```

### Testing

Please make sure to test any new functionality. Your tests should be simple and atomic and anticipate change rather than cement complex patterns.

Run tests from the root directory:

```bash
go test -v './...'
```

### Opening a Pull Request

Fork the repository and create a new branch:

```bash
git checkout -b my-branch
```

Make your changes and commit them:


```bash
git add . && git commit -m "My changes"
```

Push your changes to your fork:


```bash
git push origin my-branch
```

Feel free to reach out in a GitHub issue or discussion if you have any questions!

</details>
</file>

</files>
